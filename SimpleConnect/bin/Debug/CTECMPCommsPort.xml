<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CTECMPCommsPort</name>
    </assembly>
    <members>
        <member name="T:ControlTechniques.CommsServer.ASynchronousCommsUser">
            <summary>
            This is the main "comms user" class used to make asynchronous requests to a device.
            </summary>
            <remarks>
            Most methods in this class work asynchronously - i.e. you make a request such as <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/> and providing that method returns
            a value of <see cref="F:ControlTechniques.CommsServer.T_STATUS.OK"/> you then just wait for the <see cref="E:ControlTechniques.CommsServer.ASynchronousCommsUser.Response"/> event to fire which will contain the response from the device
            or it will indicate a timeout condition.
            
            It is important to note that only one request can be made at a time so always wait for the response before making any further requests.
            </remarks>
            <seealso cref="T:ControlTechniques.CommsServer.DataLoopUser"/>
            <seealso cref="T:ControlTechniques.CommsServer.PollingCommsUser"/>
            <seealso cref="T:ControlTechniques.CommsServer.BlockingCommsUser"/>
        </member>
        <member name="T:ControlTechniques.CommsServer.IECMPASynchronousMessageHandler">
            <summary>
            Interface to allow other objects to provide low level ECMP message sending / receiving.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.Compound(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCompoundRequest)">
            <summary>
            Send a compound request to a device.
            
            The Response event will return an object of type ECMPCompoundResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.Identify(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPIdentifyRequest)">
            <summary>
            Get Identify data from the target.
            
            The Response event will return an object of type ECMPIdentifyResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.Info(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest)">
            <summary>
            Get Info data from the target.
            
            The Response event will return an object of type ECMPInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.Interrogate(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInterrogateRequest)">
            <summary>
            Obtain a list of files in a given directory.
            
            The Response event will return an object of type FileListResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.Reset(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPResetRequest)">
            <summary>
            Reset the target.
            
            The Response event will return an object of type ECMPResetResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.TunnelFrame(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.TunnelFrameRequest)">
            <summary>
            Send a TunnelFrame message to the target.
            
            Note: The commsserver will automatically break the data into chunks
            for transmission, e.g. you can send 10K bytes and the comms layer
            will send a series of messages to get the data into the target.
            
            The Response event will return an object of type TunnelFrameResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest)">
            <summary>
            Read parameter values from the target.
            
            The Response event will return an object of type ECMPReadResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest)">
            <summary>
            Read parameter values with type information from the target.
            
            The Response event will return an object of type ECMPReadWithTypeResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest)">
            <summary>
            Write parameter values to the target.
            
            The Response event will return an object of type ECMPWriteResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.ObjectInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPObjectInfoRequest)">
            <summary>
            Get Object Info from the target.
            
            The Response event will return an object of type ECMPObjectInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.GetNextObjects(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPGetNextObjectsRequest)">
            <summary>
            Get Next Objects from the target.
            
            The Response event will return an object of type ECMPGetNextObjectsResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.FileDelete(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileDeleteMessageRequest)">
            <summary>
            Delete a file on the target.
            
            The Response event will return an object of type FileDeleteMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.FileReadBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadBytesMessageRequest)">
            <summary>
            Read the contents of a target file into an array of bytes.
            
            The Response event will return an object of type FileReadBytesMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.FileReadDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadDiskMessageRequest)">
            <summary>
            Read the contents of a target file into a file on disk.
            
            The Response event will return an object of type FileReadDiskMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.FileWriteBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest)">
            <summary>
            Write the contents of a target file from an array of bytes.
            
            The Response event will return an object of type FileWriteBytesMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.FileWriteDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest)">
            <summary>
            Write the contents of a target file from a file on disk.
            
            The Response event will return an object of type FileWriteDiskMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.FileIsWriteOnly(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest)">
            <summary>
            Check if the specified target file is write-only
            </summary>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name to check</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.FileList(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileListRequest)">
            <summary>
            Obtain a list of files in a given directory.
            
            The Response event will return an object of type FileListResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.GetSyncInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPSyncInfoRequest)">
            <summary>
            Get Sync Info
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.CyclicLink(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)">
            <summary>
            Get Cyclic Link Information
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)">
            <summary>
            Get Cyclic Link Information
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.GetDiagnostics(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPDiagnosticRequest)">
            <summary>
            Get Diagnostics
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.GetProgramStatus(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPProgramStatusRequest)">
            <summary>
            Get the status of the program running
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.INonBlockingCommsUser.SetProgramControl(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPProgramControlRequest)">
            <summary>
            Get the status of the program running
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="E:ControlTechniques.CommsServer.IECMPASynchronousMessageHandler.Response">
            <summary>
            The event on which a response will be indicated.
            </summary>
        </member>
        <member name="E:ControlTechniques.CommsServer.IECMPASynchronousMessageHandler.FileTransferProgressChanged">
            <summary>
            Event raised when the file transfer in progress progresses
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.InterfaceMessageQueueResponseNotification">
            <summary>
            This interface must be provided by clients of the message queue so that responses can be posted back to them
            when a reception or transmission succeeds or fails.
            
            This callback will be made on the main UI thread.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ICommsUser">
            <summary>
            Common interface for comms users.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ICommsUser.Go(ControlTechniques.CommsServer.Protocol)">
            <summary>
            Switches the user on to the specified protocol. If a protocol has been previously set the
            user object will relinquish its use of the port.
            </summary>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ICommsUser.Stop">
            <summary>
            Turn the user off and release the port.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ICommsUser.MaxTransmitBufferSizeBytes">
            <summary>
            Gets/sets the maximum number of bytes a client can place into a file write or tunneled frame (for example).
            This will not include message header size.
            </summary>
            <remarks>
            Note that for file write operations this value will be ignored and instead the target device will be queried for
            its buffer size at the start of the write process, though this can be suppressed by specifying the 
            <see cref="F:ControlTechniques.CommsServer.FileWriteOptions.DisableAutoBufferSize"/> flag in <see cref="T:ControlTechniques.CommsServer.FileWriteDiskMessageRequest"/> or 
            <see cref="T:ControlTechniques.CommsServer.FileWriteBytesMessageRequest"/> (in which case this value will apply).
            The actual maximum number of bytes transmitted may be less than this value as it will be aligned to a 32-bit boundary. 
            So if this property value is set to 330 the actual number of bytes will actually be 328.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ICommsUser.TheProtocol">
            <summary>
            Returns the protocol currently in use by the user. null may be
            returned if the user has not called Go (or has since called Stop).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ICommsUser.IsActive">
            <summary>
            Returns whether the user is active, i.e. <see cref="M:ControlTechniques.CommsServer.ICommsUser.Go(ControlTechniques.CommsServer.Protocol)"/> has been called.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ASynchronousCommsUser.mPort">
            <summary>
            The current Comms Port.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ASynchronousCommsUser._maxTransmitBufferSize">
            <summary>
            Maximum transmit buffer size for this user.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.#ctor">
            <summary>
            Construct the class and record the thread on which it was created. All callback events such as <see cref="E:ControlTechniques.CommsServer.ASynchronousCommsUser.Response"/> and <see cref="E:ControlTechniques.CommsServer.ASynchronousCommsUser.FileTransferProgressChanged"/>
            will be fired on this thread.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReleasePort">
            <summary>
            Releases the port used by the user.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.SetTimeouts(ControlTechniques.CommsServer.CommunicationsTimeouts)">
            <summary>
            Set the timeouts for the process. Note this will affect all comms users.
            </summary>
            <param name="timeouts">New timeouts to apply.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Timeouts">
            <summary>
            Returns the communications timeout.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Go(ControlTechniques.CommsServer.Protocol)">
            <summary>
            Switches the user on to the specified protocol. If a protocol has been previously set the
            user object will relinquish its use of the port.
            </summary>
            <param name="protocol">Protocol and settings.</param>
            <returns>Status. In practice this will always return T_STATUS.OK and you may not discover whether the communications port was opened
            successfully until you make a comms request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Stop">
            <summary>
            Stops communications and releases any communications port.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.CancelTransfer">
            <summary>
            Requests any current file transfer to be cancelled.
            </summary>
            <remarks>
            If there is no active file transfer then calling this will do nothing.
            If the a transfer is successfully cancelled then the response status for the active request will be <see cref="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_CANCELLED"/> with a
            file status of <see cref="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_CANCELLED"/>.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Transmit(ControlTechniques.CommsServer.MessageQueueRequest)">
            <summary>
            Transmits a message.
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Identify(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPIdentifyRequest)">
            <summary>
            Get Identify data from the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPIdentifyResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Compound(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCompoundRequest)">
            <summary>
            Send a compound request to a device.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPCompoundResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Info(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest)">
            <summary>
            Get Info data from the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPInfoResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Interrogate(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInterrogateRequest)">
            <summary>
            Interrogate the target to determine if commands are supported or not.
            </summary>
            <param name="address">Address of target</param>
            <param name="request">The request</param>
            <returns>A status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Reset(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPResetRequest)">
            <summary>
            Reset the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPResetResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.TunnelFrame(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.TunnelFrameRequest)">
            <summary>
            Send a TunnelFrame message to the target.
            
            Note: The commsserver will automatically break the data into chunks
            for transmission, e.g. you can send 10K bytes and the comms layer
            will send a series of messages to get the data into the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.TunnelFrameResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest)">
            <summary>
            Read parameter values from the target.
            </summary>
            <remarks>
            The <see cref="E:ControlTechniques.CommsServer.ASynchronousCommsUser.Response"/> event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPReadResponse"/>. 
            
            The values returned won't indicate things like number of decimal places. If you wish to get more information use <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest)"/>.
            </remarks>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)">
            <summary>
            Read a parameter from the target.
            </summary>
            <remarks>
            The <see cref="E:ControlTechniques.CommsServer.ASynchronousCommsUser.Response"/> event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPReadResponse"/>. 
            The values returned won't indicate things like number of decimal places. If you wish to get more information use <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>.
            </remarks>
            <param name="address">Device address.</param>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number</param>
            <returns>Status of read request.</returns>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest)"/>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest)">
            <summary>
            Read parameter values with type information from the target.
            </summary>
            <remarks>
            The <see cref="E:ControlTechniques.CommsServer.ASynchronousCommsUser.Response"/> event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPReadWithTypeResponse"/>.
            
            Most devices support reading at least 10 parameters in one request. For example, the Unidrive M RTU interface will only allow a 
            maximum of 10 whereas the Ethernet interface will do more. For maximum compatibility it is recommended you stick to no more than 10.
            
            If you wish to continually read parameters and get notifed when the value or status changes use <see cref="T:ControlTechniques.CommsServer.DataLoopUser"/>.
            </remarks>        
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)">
            <summary>
            Read a parameter from the target with full type information.
            </summary>
            <remarks>
            The <see cref="E:ControlTechniques.CommsServer.ASynchronousCommsUser.Response"/> event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPReadWithTypeResponse"/>. 
            </remarks>
            <param name="address">Device address.</param>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number</param>
            <returns>Status of read request.</returns>
            <returns>Status.</returns>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest)"/>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>        
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest)">
            <summary>
            Write parameter values to the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPWriteResponse"/>. 
            </summary>
            <param name="address">Target address</param>
            <param name="request">The request</param>
            <returns>Status.</returns>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write a parameter value to the target.
            </summary>
            <remarks>
            This function provides a simple fixed-point integer value write. For other parameter types, data types or multiple
            parameter writes, use <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest)"/>/
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPWriteResponse"/>. 
            </remarks>
            <param name="address">Target address</param>
            <param name="menu">The menu number</param>
            <param name="parameter">Parameter number</param>
            <param name="value"></param>
            <param name="dpos">Decimal places (precision) of the value.</param>
            <returns>Status.</returns>
            <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ObjectInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPObjectInfoRequest)">
            <summary>
            Get Object Info from the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPObjectInfoResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.GetNextObjects(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPGetNextObjectsRequest)">
            <summary>
            Get Next Objects from the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.ECMPGetNextObjectsResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileDelete(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileDeleteMessageRequest)">
            <summary>
            Delete a file on the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.FileDeleteMessageResponse"/>.
            </summary>
            <remarks>
            A file delete operation is performed by first opening the file for writing then deleting it.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FolderCreate(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FolderCreateMessageRequest)">
            <summary>
            Create a folder on the target.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.FolderCreateMessageResponse"/>. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileReadBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadBytesMessageRequest)">
            <summary>
            Read the contents of a target file into an array of bytes.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.FileReadBytesMessageResponse"/>.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileReadDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadDiskMessageRequest)">
            <summary>
            Read the contents of a target file into a file on disk.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.FileReadDiskMessageResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileWriteBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest)">
            <summary>
            Write the contents of a target file from an array of bytes.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.FileWriteBytesMessageResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileWriteDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest)">
            <summary>
            Write the contents of a target file from a file on disk.
            
            The Response event will return an object of type <see cref="T:ControlTechniques.CommsServer.FileWriteDiskMessageResponse"/>. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileIsWriteOnly(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest)">
            <summary>
            Check if the specified target file is write-only
            </summary>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name to check</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileExists(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileExistsRequest)">
            <summary>
            Check if the specified target file exists.
            </summary>
            <remarks>
            The existence check can be done two ways: (1) By attempting to open the file, or (2) issuing a ECMP FileExists
            command. By default method 1 is used since many devices do not support FileExists command and so this method is more
            compatbile. However you can force method 2 to be used instead by specifying <see cref="P:ControlTechniques.CommsServer.FileExistsRequest.UseFileExistsCommand"/>=true.
            </remarks>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name to check</param>
            <returns>Status of the request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileInfoRequest)">
            <summary>
            Request information about a file such as its file length.
            </summary>
            <remarks>
            Not all tagets will support this command, and the which attributes are supported is also target and file location dependant.
            Certain targets may also impose a limit on how many attributes may be requested in one request. 
            </remarks>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name and the attributes to get.</param>
            <returns>Status of the request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileList(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileListRequest)">
            <summary>
            Obtain a list of files in a given directory.
            
            The Response event will return an object of type FileListResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.GetSyncInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPSyncInfoRequest)">
            <summary>
            Get Sync Info
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.CyclicLink(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)">
            <summary>
            Issue a (legacy) cyclic-link request such as <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest"/> to create a cyclic link or <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest"/>
            to get info on a cyclic link.
            </summary>
            <param name="address">Address of target</param>
            <param name="request">Request to send</param>
            <remarks>The new <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)"/> method should be used for newer targets adhearing to the V1.0 ECMP specification.</remarks>
            <returns>Status of operation</returns>        
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)">
            <summary>
            Issue a cyclic-link request such as <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest"/> to create a cyclic link or <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest"/>
            to get info on a cyclic link.
            </summary>
            <param name="address">Address of target</param>
            <param name="request">Request to send</param>
            <returns>Status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.GetDiagnostics(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPDiagnosticRequest)">
            <summary>
            Get Diagnostics information
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.GetProgramStatus(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPProgramStatusRequest)">
            <summary>
            Get the status of the program running
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.SetProgramControl(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPProgramControlRequest)">
            <summary>
            Sets the state of the user program
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="F:ControlTechniques.CommsServer.ASynchronousCommsUser._operation">
            <summary>
            Used to cache the thread of the constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ASynchronousCommsUser.HandleMessageQueueResponse(ControlTechniques.CommsServer.MessageQueueRequest,ControlTechniques.CommsServer.MessageQueueResponse)">
            <summary>
            Invoke the subscribed events on their original threads.
            </summary>
            <param name="TheRequest"></param>
            <param name="TheResponse"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ASynchronousCommsUser.MaxTransmitBufferSizeBytes">
             <summary>
             Sets/gets the maximum number of bytes sent in a file transfer or tunneled frame.
             </summary>
             <remarks>
             An out-of-range value will be ignored (range 16-1000).
             
             The default value should be suitable in most cases. The value can be set to the <see cref="P:ControlTechniques.CommsServer.ECMPInfoResponse.BufferSizeBytes"/> obtained from the target.
            
             Note that file transfer (using <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileWriteDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest)"/> and <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.FileWriteBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest)"/>) automatically query the target device for its buffer size 
             and will use that value for the file transfer. To force the value of this property to be used instead specify the <see cref="F:ControlTechniques.CommsServer.FileWriteOptions.DisableAutoBufferSize"/> flag
             in the request.
             </remarks>
             <seealso cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Info(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest)"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.ASynchronousCommsUser.IsActive">
            <summary>
            Returns whether the user is active, i.e. <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Go(ControlTechniques.CommsServer.Protocol)"/> has been called.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ASynchronousCommsUser.TheProtocol">
            <summary>
            Returns the protocol currently in use by the user. null may be
            returned if the user has not called Go (or has since called Stop).
            </summary>
        </member>
        <member name="E:ControlTechniques.CommsServer.ASynchronousCommsUser.Response">
            <summary>
            The event on which a response will be given.
            </summary>
            <remarks>
            Most methods on this class such as <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest)"/> or 
            <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest)"/> will result in this event being
            fired when the response from the device is available, or if no response was received (timeout).
            </remarks>
        </member>
        <member name="E:ControlTechniques.CommsServer.ASynchronousCommsUser.FileTransferProgressChanged">
            <summary>
            This event will be fired whilst a file is being read from or written to a device in order to report back progress.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ASynchronousCommsUser.ResponseHandler">
            <summary>
            Handler used in asynchronous events indicating success/ fail and carrying response data.
            All events are fired on the caller's thread.
            </summary>
            <param name="User"></param>
            <param name="TheResponseData"></param>
            <param name="Status"></param>
        </member>
        <member name="T:ControlTechniques.CommsServer.BaudRate">
            <summary>
            Describes serial baud rates.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BaudRate.Convert(System.String)">
            <summary>
            Converts a baudrate as a string, e.g. "57600" to the appropriate enum value.
            </summary>
            <param name="str">Baudrate string</param>
            <returns>Baud-rate. If string given is not recognised then 19200 baud is returned.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BaudRate.Convert(System.Int32)">
            <summary>
            Converts a baudrate as a integer into the enum equivalent.
            </summary>
            <param name="rate">Baudrate.</param>
            <returns>One of <see cref="T:ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE"/>. If value given is not recognised then baud rate of 19200 is returned.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BaudRate.ToString(ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE)">
            <summary>
            Returns string value of baudrate.
            </summary>
            <param name="baudrate">Baudrate</param>
            <returns>String value.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BaudRate.ToInt(ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE)">
            <summary>
            Returns integer value of baudrate.
            </summary>
            <param name="baudrate">Baudrate</param>
            <returns>Integer value.</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE">
            <summary>
            Serial RTU baud rates.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE.BAUD_115200">
            <summary>115200 baud.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE.BAUD_57600">
            <summary>57600 baud.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE.BAUD_38400">
            <summary>38400 baud.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE.BAUD_19200">
            <summary>19200 baud.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileExistsRequest">
            <summary>
            Used for file existence check.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPUserRequest">
            <summary>
            This is the base class for all user requests to transmit.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPUserRequest.Tag">
            <summary>
            Client tag. This is not used by the comms layer and is a convenience to client applications to store their own data in.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileExistsRequest.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileExistsRequest.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="filename">Target filename.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileExistsRequest.TargetFileName">
            <summary>
            File on target.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileExistsRequest.UseFileExistsCommand">
            <summary>
            If this is set then the ECMP FileExists command will be used instead of the more compatible (and default) FileOpen method.
            </summary>
            <remarks>
            Using FileExists is more efficient but many targets do not support it. Use <see cref="T:ControlTechniques.CommsServer.ECMPInterrogateRequest"/> for the command
            with the code 0x2A to check if a target supports it.
            </remarks>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileExistsResponse">
            <summary>
            Response to a file exist request.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPUserResponse">
            <summary>
            This is the base class for all responses passed back to users.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPUserResponse.TimeStamp">
            <summary>
            Timestamp message was received.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileExistsResponse.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileExistsResponse.#ctor(ControlTechniques.CommsServer.T_FILE_STATUS)">
            <summary>
            Constructor.
            </summary>
            <param name="status">Status.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileExistsResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileExistsResponse.TargetFileName">
            <summary>
            The filename.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileExistsResponse.Status">
            <summary>
            The status response from the target.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileExistsResponse.Exists">
            <summary>
            Indicates if file exists on target (i.e. Status = OK).
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileWriteOptions">
            <summary>
            Options for writing files to a target.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.FileWriteOptions.DisableAutoBufferSize">
            <summary>
            Specify this flag to suppress automatic buffer size calculation. Without this set the target device will be queried for
            how much data it can accept per packet when the file transfer is started and this will be used during the write, overriding 
            the default value given by <see cref="P:ControlTechniques.CommsServer.ICommsUser.MaxTransmitBufferSizeBytes"/>. 
            If you wish to specify an exact buffer size to use instead then set this flag and set the appropriate buffer size via <see cref="P:ControlTechniques.CommsServer.ICommsUser.MaxTransmitBufferSizeBytes"/>.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileWriteRequestBase">
            <summary>
            Base class for FileWriteDisk/BytesMessageRequest.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ITargetFileAction.TargetFileName">
            <summary>
            The target file name
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileWriteRequestBase.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileWriteRequestBase.#ctor(System.String,ControlTechniques.CommsServer.FileWriteOptions)">
            <summary>
            Constructor.
            </summary>
            <param name="targetFilename">Filename on target.</param>
            <param name="options">(Optional) Options.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileWriteRequestBase.TargetFileName">
            <summary>
            Path and name of the file you wish to write to on the target device, e.g. "/sys/prog/user".
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileWriteRequestBase.Options">
            <summary>
            Options for the file write.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileWriteResponseBase`1">
            <summary>
            Base class for file write responses.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileWriteResponseBase`1.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileWriteResponseBase`1.TargetFileName">
            <summary>
            The path and name of the file written to on the target.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileWriteResponseBase`1.Status">
            <summary>
            Status of the file write.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileWriteResponseBase`1.TimeTaken">
            <summary>
            Overall time the file write took.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.Internal.ByteArrayMerger">
            <summary>
            This is a utility class that holds a hash of byte array references and
            allows them to be appended together to form one single byte array.
            </summary>
            <remarks>
            This hold references to the byte arrays, so the content of the arrays can still be
            altered after adding them to this object.
            
            The order of the data in the merged byte array is dependent upon the order
            the byte arrays were added to the dictionary.
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.Internal.ByteArrayMerger.mUniqueNum">
            <summary>
            Unique number for unnamed arrays.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteArrayMerger.Add(System.Byte[])">
            <summary>
            Adds an unnamed block of data.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteArrayMerger.GetOffset(System.String)">
            <summary>
            Get the byte offset to the requested block of data.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteArrayMerger.AddPadding(System.Int32)">
            <summary>
            Add padding to merged byte array. Return padding size.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteArrayMerger.Set(System.String,System.Byte[])">
            <summary>
            Set the buffer with a new value.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteArrayMerger.Merge(System.Byte[],System.Byte[])">
            <summary>
            Merges (concatinates) two arrays.
            </summary>
            <param name="b1">Array 1</param>
            <param name="b2">Array 2</param>
            <returns>Combined byte array.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.Internal.ByteArrayMerger.Length">
            <summary>
            Get the overall length (in bytes) of the data.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Internal.ByteArrayMerger.Bytes">
            <summary>
            Get the combined data array.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.Internal.ByteConverter">
            <summary>
            Big endian byte converter.
            Provides static methods that take various source data types and returns them as a byte array.
            Also can output as a string for including into a source code file.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes">
            <summary>
            Returns a null byte array.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.Char)">
            <summary>
            Converts a UInt8 into a byte[]
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.UInt16)">
            <summary>
            Converts a UInt16 into a byte[] array.
            </summary>
            <param name="val">Unsigned short value.</param>
            <returns>Byte array, big-endian format.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.UInt32)">
            <summary>
            Converts a UInt32 into a byte[] array.
            </summary>
            <param name="val">Unsigned integer value.</param>
            <returns>Byte array, big-endian format.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.Int32)">
            <summary>
            Converts an integer into a byte[] array (integer is converted into a UInt32).
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Writes a UInt16 value into a given byte array.
            </summary>
            <param name="val">Unsigned short value.</param>
            <param name="by">The byte array to write into.</param>
            <param name="offset">The byte offset into the array.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            Writes a UInt32 value into a given byte array.
            </summary>
            <param name="val">Unsigned integer value.</param>
            <param name="by">The byte array to write into.</param>
            <param name="offset">The byte offset into the array.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes an integer value into a given byte array.
            </summary>
            <param name="val">Integer value.</param>
            <param name="by">The byte array to write into.</param>
            <param name="offset">The byte offset into the array.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.UInt16[])">
            <summary>
            Converts a UInt16[] array into a byte[] array.
            </summary>
            <param name="data">Unsigned short array.</param>
            <returns>Byte array, big-endian format.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.UInt32[])">
            <summary>
            Converts a UInt32[] array into a byte[] array.
            </summary>
            <param name="data">Unsigned integer array.</param>
            <returns>Byte array, big-endian format.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Extracts part of a byte array into a new byte[] array.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetBytes(System.String,System.Int32)">
            <summary>
            String to byte array, padded right with \0.
            </summary>
            <param name="s">The string.</param>
            <param name="requiredLength">Buffer length.</param>
            <returns>A byte buffer of required length filled with ASCII bytes from given string. If
            string is null or empty then the array returned will be filled with zeros.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetHexString(System.UInt16)">
            <summary>
            Returns a value formatted as "0xMSB,0xLSB, "
            </summary>
            <param name="val">Value to be converted.</param>
            <returns>String.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Internal.ByteConverter.GetHexString(System.UInt32)">
            <summary>
            Returns a value formatted as "0xMSB,0xNSB,0xNSB,0xLSB, "
            </summary>
            <param name="val">Value to be converted.</param>
            <returns>String.</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ByteManipulators">
            <summary>
            This class provides operations to convert to and from arrays of bytes for values such as 32-bit signed ints.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ByteManipulators.SwapByteOrder(System.Int16)">
            <summary>
            High performance byte order reversal method for converting between little endian and big endian values
            </summary>
            <param name="value">value to swap the byte order of</param>
            <returns>value with byte order reversed</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ByteManipulators.SwapByteOrder(System.UInt16)">
            <summary>
            High performance byte order reversal method for converting between little endian and big endian values
            </summary>
            <param name="value">value to swap the byte order of</param>
            <returns>value with byte order reversed</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ByteManipulators.SwapByteOrder(System.Int32)">
            <summary>
            High performance byte order reversal method for converting between little endian and big endian values
            </summary>
            <param name="value">value to swap the byte order of</param>
            <returns>value with byte order reversed</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ByteManipulators.SwapByteOrder(System.UInt32)">
            <summary>
            High performance byte order reversal method for converting between little endian and big endian values
            </summary>
            <param name="value">value to swap the byte order of</param>
            <returns>value with byte order reversed</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ByteManipulators.SwapByteOrder(System.Int64)">
            <summary>
            High performance byte order reversal method for converting between little endian and big endian values
            </summary>
            <param name="value">value to swap the byte order of</param>
            <returns>value with byte order reversed</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ByteManipulators.SwapByteOrder(System.UInt64)">
            <summary>
            High performance byte order reversal method for converting between little endian and big endian values
            </summary>
            <param name="value">value to swap the byte order of</param>
            <returns>value with byte order reversed</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ByteManipulators.ToTime64(System.UInt32,System.UInt32)">
            <summary>
            Converts the specified seconds and nanoseconds to a Time64 representation for sending in an ecmp request
            </summary>
            <param name="seconds"></param>
            <param name="nanoSeconds"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ByteManipulators.FromTime64(System.UInt64,System.UInt32@,System.UInt32@)">
            <summary>
            Converts a Time64 value back into seconds and nanoseconds
            </summary>
            <param name="time64"></param>
            <param name="seconds"></param>
            <param name="nanoSeconds"></param>
        </member>
        <member name="T:ControlTechniques.CommsServer.CommsAddress">
            <summary>
            A comms address used to represent a target device (node).
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.CommsAddress.IpAddressPattern">
            <summary>
            Regex for IP Address to split into parts.
            </summary>
            This regex will accept "1.2.3.4.5" is accepted (5 being the slot number) so the code needs to trap for that.
        </member>
        <member name="F:ControlTechniques.CommsServer.CommsAddress.RtuAddressPattern">
            <summary>
            Regex for RTU address. Groups: 1=Drive, 3=Option
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.CommsAddress.MinRtuAddress">
            <summary>
            Minimum allowed RTU address.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.CommsAddress.MaxRtuAddress">
            <summary>
            Maximum allowed RTU address.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.CommsAddress._primary">
            <summary>
            The primary (usually drive) address. This could be a RTU number, e.g. "2" or an IP address, e.g. "168.1.200.34".
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.CommsAddress._slot">
            <summary>
            The option number on the device. An empty string indicates that no option is specified.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.#ctor(System.String,System.Boolean,System.String)">
            <summary>
            Private constructor.
            </summary>
            <param name="primary"></param>
            <param name="isAnIPAddress"></param>
            <param name="option"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an RTU address.
            </summary>
            <param name="rtuAddress">RTU node address (range 1-247).</param>
            <param name="slotNumber">Slot number. Specify 0 for the drive, -1 for no slot (intercept) or 1+ for a specific slot. Default is -1 (no slot).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Raised if address is not in range of 1-247.</exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Create an RTU address.
            </summary>
            <param name="ipAddress">IP address of node.</param>
            <param name="slotNumber">Slot number. Specify 0 for the drive, -1 for no slot (intercept) or 1+ for a specific slot. Default is -1 (no slot).</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.#ctor(ControlTechniques.CommsServer.CommsAddress,System.Int32)">
            <summary>
            Public constructor to return a new CommsAddress based upon another address but with a different option slot number.
            </summary>
            <param name="address">Comms address.</param>
            <param name="optionSlot">Option slot to set. A value of -1 indicates no option slot.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.CreateRTUAddress(System.Int32)">
            <summary>
            Construct an RTU-style address (no option).
            </summary>
            <param name="nodeAddress">RTU node address (range 1-247).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Raised if address is not in range of 1-247.</exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.CreateRTUAddressWithOption(System.Int32,System.Int32)">
            <summary>
            Construct an RTU-style address (with option).
            </summary>
            <param name="nodeAddress">RTU node address (range 1-247).</param>
            <param name="slotNumber">Slot number. Specify 0 for drive, or 1+ for specific slot.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Raised if address is not in range of 1-247.</exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.CreateIPAddress(System.String)">
            <summary>
            Construct an IP address (no option).
            </summary>
            <param name="nodeAddress">IP address in the format like "192.168.1.100" or "(192.168.1.100)".</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.CreateIPAddress(System.Net.IPAddress)">
            <summary>
            Construct an IP address (no option).
            </summary>
            <param name="address">IP address</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.CreateIPAddressWithOption(System.String,System.Int32)">
            <summary>
            Construct an IP address (with option).
            </summary>
            <param name="nodeAddress">IP address in the format like "192.168.1.100" or "(192.168.1.100)".</param>
            <param name="slotNumber">Slot number. Specify 0 for drive, -1 for no slot, or 1+ for specific slot.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.CreateIPAddressWithOption(System.Net.IPAddress,System.Int32)">
            <summary>
            Construct an IP address (with option).
            </summary>
            <param name="address">IP address.</param>
            <param name="slotNumber">Slot number. Specify 0 for drive, -1 for no slot, or 1+ for specific slot.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.Equals(ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.CreateIPAddressFromValue(System.UInt32,System.Int32)">
            <summary>
            Construct an IP address from an integer value such as the value read back from a drive IP address parameter.
            Value is expecetd in big-endian format (aka network byte order) such that 3232235876 = 0xc0a80164 = 192.168.1.100.
            </summary>
            <param name="value">Value.</param>
            <param name="optionNumber">Option slot number. Omit or specify -1 for no slot or 0+ to indicate slot specific addressing is required.</param>
            <returns>A comms address.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.CompareTo(ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Compares one address with another.
            Useful when sorting addresses numerically.
            RTU addresses are considered less than Ethernet.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.Parse(System.String)">
            <summary>
            Attempts to parse an address string.
            </summary>
            <param name="address">address string.</param>
            <returns>A CommsAddress object if parsing succeeded.</returns>
            <exception cref="T:System.ArgumentNullException">address isnull.</exception>
            <exception cref="T:System.FormatException">address is not in the correct format.</exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommsAddress.TryParse(System.String,ControlTechniques.CommsServer.CommsAddress@)">
            <summary>
            Parse an address string.
            </summary>
            <param name="address">A new CommsAddress object or null if the parsing failed..</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.WholeAddressAsString">
            <summary>
            Returns the complete address in a form suitable for use with CTCommsServer.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.PrimaryAddressAsInteger">
            <summary>
            Returns the primary device (usually drive) as an integer. Do not call this method unless the object contains
            an RTU address or a value of -1 will be returned.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.PrimaryAddressAsString">
            <summary>
            Returns the primary device (usually drive) in a format suitable for use with the CTCommsServer.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.OptionAddressAsString">
            <summary>
            Returns the option address as a string. An empty string will be returned if there is no option addressed.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.OptionAddressAsInteger">
            <summary>
            Returns the option address as an integer. -1 will be returned if there is no option addressed.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.MACAddress">
            <summary>
            Optional MAC Address
            </summary>
            <remarks>
            Used for discovery process
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.DhcpEnabled">
            <summary>
            Is DHCP Enabled for this node
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.DhcpAcquired">
            <summary>
            Has the address this node has been assigned via DHCP
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.Netmask">
            <summary>
            Subnet Mask for this node
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.Gateway">
            <summary>
            Gateway IP address for this node
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.IsIPBased">
            <summary>
            Indicates if the address is for use with Ethernet comms (i.e. is an IPv4 address)
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.IpAddress">
            <summary>
            Gets the primary IP address. Returns null if address is not an IP address.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommsAddress.InterceptAddress">
            <summary>
            Returns an intercept address. Indended for use with SML file generation. See
            <see cref="P:ControlTechniques.CommsServer.SmlCommsUser.CommsAddress"/> property.
            </summary>
            <returns>An intercept address (RTU address with option set to -1).</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.CommunicationsTimeouts">
            <summary>
            Defines timeouts used in communications.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.CommunicationsTimeouts.MinimumTimeout">
            <summary>
            Minimum used in <see cref="!:ExtendMainTimeouts"/>.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommunicationsTimeouts.#ctor">
            <summary>
            Construct default timeouts.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommunicationsTimeouts.#ctor(ControlTechniques.CommsServer.CommunicationsTimeouts)">
            <summary>
            Copy constructor.
            </summary>
            <param name="other">Settings to copy.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommunicationsTimeouts.LoadCommsUserSettings(System.Int32)">
            <summary>
            Load the comms users settings
            </summary>
            <param name="commsUserId"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommunicationsTimeouts.ExtendTimeouts(System.Int32)">
            <summary>
            Extends general timeouts by the given amount.
            </summary>
            <param name="ms">Number of milliseconds to add to timeout properties. May be negative to reduce the timeouts.</param>
            <remarks>
            Note that the actual timeout values are adjusted so calling this with a value of 0 has no effect.
            
            The timeouts that are altered are:  <see cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.DefaultTimeout"/>, <see cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileCreateTimeout"/>, <see cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileReadTimeout"/>,
            <see cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileWriteTimeout"/>, <see cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileCloseTimeout"/>, <see cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.IdentifyTimeout"/> and <see cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TunnelMessageTimeout"/>.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.DefaultTimeout">
            <summary>
            The default timeout used (ms)
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TotalDefaultTimeout">
            <summary>
            This is the total default timeout used inside the comms server including retries and inter retry period
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.IdentifyTimeout">
            <summary>
            The timeout to be used when asking for a device's identity during node discovery.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TotalIdentifyTimeout">
            <summary>
            This is the total default timeout used inside the comms server including retries and inter retry period
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileCreateTimeout">
            <summary>
            The timeout to be used when creating a file (ms).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TotalFileCreateTimeout">
            <summary>
            This is the total file create timeout used inside the comms server including retries and inter retry period
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileReadTimeout">
            <summary>
            The timeout to be used when when reading a fragment of a file.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TotalFileReadTimeout">
            <summary>
            This is the total default timeout used inside the comms server including retries and inter retry period
            </summary>        
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileWriteTimeout">
            <summary>
            The timeout to be used when when writing a fragment of a file.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TotalFileWriteTimeout">
            <summary>
            This is the total default timeout used inside the comms server including retries and inter retry period
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileCloseTimeout">
            <summary>
            The timeout to be used when closing a file.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FileDeleteTimeout">
            <summary>
            The timeout to be used when when deleting a file.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TotalFileDeleteTimeout">
            <summary>
            This is the total default timeout used inside the comms server including retries and inter retry period
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.PostFileWriteTimeout">
            <summary>
            The timeout to be used after creating and then closing a file.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FailOneHoldOffMs">
            <summary>
            The number of milliseconds to hold off comms after the first comms failure to a node.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.FailTwoHoldOffMs">
            <summary>
            The number of milliseconds to hold off comms after the second comms failure to a node.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.PostMessageDelay">
            <summary>
            The delay for which a port message queue is to be paused after normal message transmission.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.PostResetDelay">
            <summary>
            The delay for which a port message queue is to be paused after a reset message transmission.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TunnelNodeResettingDelay">
            <summary>
            The timeout to be used after a node using tunnel messages has indicated in a response that it is resetting.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.NumberOfRetries">
            <summary>
            Number of retries internally within the comms server
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.InterRetryPeriod">
            <summary>
            Period between retries internally within the comms server
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TunnelMessageTimeout">
            <summary>
            Timeout for tunnel messages.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.Default">
            <summary>
            Default timeouts.
            </summary>
            <seealso cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.ForProgramming"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.CommunicationsTimeouts.ForProgramming">
            <summary>
            Default timeouts that are better suited for programming device firmware / user programs.
            </summary>
            <seealso cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.Default"/>
        </member>
        <member name="T:ControlTechniques.CommsServer.CommunicationsTimeouts.T_TIMEOUT_CONSTANTS">
            <summary>
            Default timeout constants.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.CommunicationsTimeouts.DefaultTimeouts">
            <summary>
            Default timeouts. These are initialised to the values in <see cref="T:ControlTechniques.CommsServer.CommunicationsTimeouts.T_TIMEOUT_CONSTANTS"/>.
            These are used as defaults for new comms users.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.CommunicationsTimeouts.DefaultTimeouts.#cctor">
            <summary>
            Constructor - runs once to load settings from registry (if available).
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ComPortHelper">
            <summary>
            Utility functions for retreiving and working with the names of the serial communications ports available on the PC.
            </summary>
            <description>
            You may also use <see cref="T:System.IO.Ports.SerialPort"/> as a quicker way to get a list of serial ports however this class 
            adds in 
            </description>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortHelper.EnumerateDevices(System.UInt32,System.String)">
            <summary>
            Enumerates the devices of the type specified returning the name of the <paramref name="deviceIndex"/> entry in the device list
            </summary>
            <param name="deviceIndex">Index of the device.</param>
            <param name="className">Name of the class.</param>
            <returns>The friendly name of the device, or the device description if the device has no friendly name</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortHelper.GetPorts">
            <summary>
            Gets the port information in the order that they are defined in the ports device list.
            </summary>
            <returns>An IEnumerable object to allow iteration of the list of names.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortHelper.GetComPortNumbers">
            <summary>
            Gets the COM port numbers sorted in order of port number.
            You may find it easier to call <see cref="M:System.IO.Ports.SerialPort.GetPortNames"/>.
            </summary>
            <returns>An IEnumerable object to allow iteration of the list of numbers in the format "COMx" where X is the number 
            of the port</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortHelper.GetInformationForPort(System.Int32)">
            <summary>
            Gets the name for port.
            </summary>
            <param name="portNumber">The port number.</param>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ComPortInformation">
            <summary>
            Holds name information about a serial COM port as returned by the <see cref="T:ControlTechniques.CommsServer.ComPortHelper"/> class.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ComPortHelper"/>.
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.#ctor(System.Int32)">
            <summary>
            Simple name constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.ComPortInformation"/> class.
            </summary>
            <param name="friendlyName">The friendly name of the port as reported by windows an example would be "Prolific USB to Serial Converter (COM1)</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.ComPortInformation"/> class.
            </summary>
            <param name="description">The description of the port.</param>
            <param name="portNumber">The port number.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.IsValidFriendlyName(System.String)">
            <summary>
            Determines whether <paramref name="friendlyName"/> is a valid friendly name.
            </summary>
            <param name="friendlyName">The friendly name of the port as reported by windows an example would be "Prolific USB to Serial Converter (COM1)</param>
            <returns>
            	<c>true</c>if the friendly name is value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.GetPortNumberAndDescriptionFromFriendlyName(System.String,System.String@)">
            <summary>
            Gets the port number from the friendly name.
            </summary>
            <param name="friendlyName">The friendly name of the port.</param>
            <param name="description">The description string from the friendly name</param>
            <returns>The port number from the friendly name</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.GetPortNumberFromSimpleName(System.String)">
            <summary>
            Parses COMx and returns the number at the end, so "COM3" will return 3. If string is not valid then 0 is returned.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.CompareTo(ControlTechniques.CommsServer.ComPortInformation)">
            <summary>
            Compares another <see cref="T:ControlTechniques.CommsServer.ComPortInformation"/> object with this one.  Comparison is made based upon the port number.
            </summary>
            <param name="other">The other <see cref="T:ControlTechniques.CommsServer.ComPortInformation"/> object to compare to.</param>
            <returns>-1 if this port number is less than the other port number, 1 if it is greater or zero if they are equal or the other object is in fact this object</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.Equals(ControlTechniques.CommsServer.ComPortInformation)">
            <summary>
            True if this object is the same as the other object.
            </summary>
            <param name="other">The other.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            	<c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.op_Equality(ControlTechniques.CommsServer.ComPortInformation,ControlTechniques.CommsServer.ComPortInformation)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.op_Inequality(ControlTechniques.CommsServer.ComPortInformation,ControlTechniques.CommsServer.ComPortInformation)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ComPortInformation.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ComPortInformation.Description">
            <summary>
            Gets the friendly name of the com port this is the name of the port as reported by device manager. An example would be "Prolific USB to Serial Converter"
            </summary>
            <value>The description of the com port i.e. "Prolific USB to Serial Converter".</value>
        </member>
        <member name="P:ControlTechniques.CommsServer.ComPortInformation.PortNumber">
            <summary>
            Gets the number of the comport, for example this property is 1 for COM1
            </summary>
            <exception cref="T:System.IO.InvalidDataException">If the port number is negative</exception>
        </member>
        <member name="P:ControlTechniques.CommsServer.ComPortInformation.PortName">
            <summary>
            Gets the port name in its traditional form i.e. COM1
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ComPortInformation.FriendlyName">
            <summary>
            Get the ports friendly name as reported in device manager.  An example would be "Prolific USB to Serial Converter (COM12)"
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.BlockingCommsUser">
            <summary>
            Provides a "comms user" that blocks whilst waiting for responses.
            </summary>
            <remarks>
            You should only use this class in non-UI threads otherwise your application will appear frozen.
            
            It is recommended to use <see cref="T:ControlTechniques.CommsServer.ASynchronousCommsUser"/> which provides an event based system.
            </remarks>
            <seealso cref="T:ControlTechniques.CommsServer.ASynchronousCommsUser"/>
            <seealso cref="T:ControlTechniques.CommsServer.PollingCommsUser"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.Compound(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCompoundRequest,ControlTechniques.CommsServer.ECMPCompoundResponse@)">
            <summary>
            Send a compound request to a device.
            
            The Response event will return an object of type ECMPCompoundResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.Identify(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPIdentifyRequest,ControlTechniques.CommsServer.ECMPIdentifyResponse@)">
            <summary>
            Get Identify data from the target.
            
            The Response event will return an object of type ECMPIdentifyResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.Info(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest,ControlTechniques.CommsServer.ECMPInfoResponse@)">
            <summary>
            Get Info data from the target.
            
            The Response event will return an object of type ECMPInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.Interrogate(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInterrogateRequest,ControlTechniques.CommsServer.ECMPInterrogateResponse@)">
            <summary>
            Interrogate the target to determine if commands are supported or not.
            </summary>
            <param name="Address">Address of target</param>
            <param name="Request">The request</param>
            <returns>A status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.Reset(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPResetRequest,ControlTechniques.CommsServer.ECMPResetResponse@)">
            <summary>
            Reset the target.
            
            The Response event will return an object of type ECMPResetResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.TunnelFrame(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.TunnelFrameRequest,ControlTechniques.CommsServer.TunnelFrameResponse@)">
            <summary>
            Send a TunnelFrame message to the target.
            
            Note: The commsserver will automatically break the data into chunks
            for transmission, e.g. you can send 10K bytes and the comms layer
            will send a series of messages to get the data into the target.
            
            The Response event will return an object of type TunnelFrameResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest,ControlTechniques.CommsServer.ECMPReadResponse@)">
            <summary>
            Read parameter values from the target.
            
            The Response event will return an object of type ECMPReadResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest,ControlTechniques.CommsServer.ECMPReadWithTypeResponse@)">
            <summary>
            Read parameter values with type information from the target.
            
            The Response event will return an object of type ECMPReadWithTypeResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest,ControlTechniques.CommsServer.ECMPWriteResponse@)">
            <summary>
            Write parameter values to the target.
            
            The Response event will return an object of type ECMPWriteResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.ObjectInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPObjectInfoRequest,ControlTechniques.CommsServer.ECMPObjectInfoResponse@)">
            <summary>
            Get Object Info from the target.
            
            The Response event will return an object of type ECMPObjectInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.GetNextObjects(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPGetNextObjectsRequest,ControlTechniques.CommsServer.ECMPGetNextObjectsResponse@)">
            <summary>
            Get Next Objects from the target.
            
            The Response event will return an object of type ECMPGetNextObjectsResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.FileDelete(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileDeleteMessageRequest,ControlTechniques.CommsServer.FileDeleteMessageResponse@)">
            <summary>
            Delete a file on the target.
            
            The Response event will return an object of type FileDeleteMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.FileReadBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadBytesMessageRequest,ControlTechniques.CommsServer.FileReadBytesMessageResponse@)">
            <summary>
            Read the contents of a target file into an array of bytes.
            
            The Response event will return an object of type FileReadBytesMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.FileReadDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadDiskMessageRequest,ControlTechniques.CommsServer.FileReadDiskMessageResponse@)">
            <summary>
            Read the contents of a target file into a file on disk.
            
            The Response event will return an object of type FileReadDiskMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.FileIsWriteOnly(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageResponse@)">
            <summary>
            Check if the specified target file is write-only
            </summary>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name to check</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.FileWriteBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest,ControlTechniques.CommsServer.FileWriteBytesMessageResponse@)">
            <summary>
            Write the contents of a target file from an array of bytes.
            
            The Response event will return an object of type FileWriteBytesMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.FileWriteDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest,ControlTechniques.CommsServer.FileWriteDiskMessageResponse@)">
            <summary>
            Write the contents of a target file from a file on disk.
            
            The Response event will return an object of type FileWriteDiskMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.FileList(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileListRequest,ControlTechniques.CommsServer.FileListResponse@)">
            <summary>
            Obtain a list of files in a given directory.
            
            The Response will be an object of type FileListResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.GetSyncInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPSyncInfoRequest,ControlTechniques.CommsServer.ECMPSyncInfoResponse@)">
            <summary>
            Gets Sync Info
            </summary>
            <param name="address">address of drive from which to get sync info</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.CyclicLink(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase,ControlTechniques.CommsServer.ECMPCyclicLinkResponse@)">
            <summary>
            Get Cyclic Link Information
            </summary>
            <remarks>The new <seealso cref="M:ControlTechniques.CommsServer.IBlockingCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase,ControlTechniques.CommsServer.ECMPCyclicLinkResponse@)"/> method should be used for newer targets adhearing to the V1.0 ECMP specification.</remarks>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase,ControlTechniques.CommsServer.ECMPCyclicLinkResponse@)">
            <summary>
            Get Cyclic Link Information
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.GetDiagnostics(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPDiagnosticRequest,ControlTechniques.CommsServer.ECMPDiagnosticResponse@)">
            <summary>
            Get Diagnostics
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.IBlockingCommsUser.GetProgramStatus(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPProgramStatusRequest,ControlTechniques.CommsServer.ECMPProgramStatusResponse@)">
            <summary>
            Get the status of the user program
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="F:ControlTechniques.CommsServer.BlockingCommsUser.mSemaphore">
            <summary>
            Semaphore used to block the calling thread until a response is received.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.BlockingCommsUser.mPort">
            <summary>
            The current Comms Port.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.BlockingCommsUser.mResponse">
            <summary>
            The received message response.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.BlockingCommsUser._syncObject">
            <summary>
            This object is used to synchronise access across threads
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.BlockingCommsUser._maxTransmitBufferSize">
            <summary>
            Maximum transmit buffer size for this user.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.ReleasePort(System.Boolean)">
            <summary>
            Releases the port used by the user.
            </summary>
            <param name="wait">Set to true to force port manager to wait until port is fully released.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.#ctor">
            <summary>
            Construct the user.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.SetTimeouts(ControlTechniques.CommsServer.CommunicationsTimeouts)">
            <summary>
            Set the timeouts for the process.
            </summary>
            <param name="timeouts"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Timeouts">
            <summary>
            Returns the communications timeout.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Go(ControlTechniques.CommsServer.Protocol)">
            <summary>
            Switches the user on to the specified protocol. If a protocol has been previously set the
            user object will relinquish its use of the port.
            </summary>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Stop">
            <summary>
            Turn the user off and release the port.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Stop(System.Boolean)">
            <summary>
            Turn the user off and release the port, optionally waiting for port to really be released.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Transmit(ControlTechniques.CommsServer.MessageQueueRequest)">
            <summary>
            Transmits a message.
            </summary>
            <param name="Request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Compound(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCompoundRequest,ControlTechniques.CommsServer.ECMPCompoundResponse@)">
            <summary>
            Send a compound request to a device.
            
            The Response event will return an object of type ECMPCompoundResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Identify(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPIdentifyRequest,ControlTechniques.CommsServer.ECMPIdentifyResponse@)">
            <summary>
            Get Identify data from the target.
            
            The Response event will return an object of type ECMPIdentifyResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Info(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest,ControlTechniques.CommsServer.ECMPInfoResponse@)">
            <summary>
            Get Info data from the target.
            
            The Response event will return an object of type ECMPInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Interrogate(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInterrogateRequest,ControlTechniques.CommsServer.ECMPInterrogateResponse@)">
            <summary>
            Interrogate the target to determine if commands are supported or not.
            </summary>
            <param name="address">Address of target</param>
            <param name="request">The request</param>
            <param name="response">The response from the target</param>
            <returns>Response status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Reset(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPResetRequest,ControlTechniques.CommsServer.ECMPResetResponse@)">
            <summary>
            Reset the target.
            
            The Response event will return an object of type ECMPResetResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.TunnelFrame(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.TunnelFrameRequest,ControlTechniques.CommsServer.TunnelFrameResponse@)">
            <summary>
            Send a TunnelFrame message to the target.
            
            Note: The commsserver will automatically break the data into chunks
            for transmission, e.g. you can send 10K bytes and the comms layer
            will send a series of messages to get the data into the target.
            
            The Response event will return an object of type TunnelFrameResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest,ControlTechniques.CommsServer.ECMPReadResponse@)">
            <summary>
            Read parameter values from the target.
            
            The Response event will return an object of type ECMPReadResponse. 
            </summary>
            <seealso cref="M:ControlTechniques.CommsServer.BlockingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,ControlTechniques.CommsServer.ECMPReadResponse@)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,ControlTechniques.CommsServer.ECMPReadResponse@)">
            <summary>
            Read a single parameter value from the target.
            The returned value will be whole integer and won't convey any precision. Use <see cref="M:ControlTechniques.CommsServer.BlockingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,ControlTechniques.CommsServer.ECMPReadWithTypeResponse@)"/>
            to get more complete information.
            </summary>
            <param name="address"></param>
            <param name="menu">The menu number</param>
            <param name="parameter">Parameter number</param>
            <param name="response">Returned response</param>
            <returns>Status</returns>
            <seealso cref="M:ControlTechniques.CommsServer.BlockingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest,ControlTechniques.CommsServer.ECMPReadResponse@)"/>
            <seealso cref="M:ControlTechniques.CommsServer.BlockingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest,ControlTechniques.CommsServer.ECMPReadWithTypeResponse@)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest,ControlTechniques.CommsServer.ECMPReadWithTypeResponse@)">
            <summary>
            Read parameter values with type information from the target.
            
            The Response event will return an object of type ECMPReadWithTypeResponse. 
            </summary>
            <seealso cref="M:ControlTechniques.CommsServer.BlockingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,ControlTechniques.CommsServer.ECMPReadWithTypeResponse@)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,ControlTechniques.CommsServer.ECMPReadWithTypeResponse@)">
            <summary>
            Read a single parameter value with type information from the target.
            </summary>
            <param name="address">Target address</param>
            <param name="menu">The menu number</param>
            <param name="parameter">Parameter number</param>
            <param name="response">Returned response</param>
            <returns>Status</returns>
            <seealso cref="M:ControlTechniques.CommsServer.BlockingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest,ControlTechniques.CommsServer.ECMPReadWithTypeResponse@)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest,ControlTechniques.CommsServer.ECMPWriteResponse@)">
            <summary>
            Write parameter values to the target.
            
            The Response event will return an object of type ECMPWriteResponse. 
            </summary>
            <param name="address">Target address</param>
            <param name="request">The request</param>
            <param name="response">The response</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,System.Int32,System.Int32,ControlTechniques.CommsServer.ECMPWriteResponse@)">
            <summary>
            Write a parameter value to the target.
            </summary>
            <remarks>
            This method provides a simple fixed-point integer write. For writing other data types or to multiple parameters use the
            <see cref="M:ControlTechniques.CommsServer.BlockingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest,ControlTechniques.CommsServer.ECMPWriteResponse@)"/> method.
            </remarks>
            <param name="address">Target address</param>
            <param name="menu">The menu number</param>
            <param name="parameter">Parameter number</param>
            <param name="value"></param>
            <param name="dpos">Decimal places (precision) of the value.</param>
            <param name="response">The response</param>
            <seealso cref="M:ControlTechniques.CommsServer.BlockingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest,ControlTechniques.CommsServer.ECMPWriteResponse@)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.ObjectInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPObjectInfoRequest,ControlTechniques.CommsServer.ECMPObjectInfoResponse@)">
            <summary>
            Get Object Info from the target.
            
            The Response event will return an object of type ECMPObjectInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.GetNextObjects(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPGetNextObjectsRequest,ControlTechniques.CommsServer.ECMPGetNextObjectsResponse@)">
            <summary>
            Get Next Objects from the target.
            
            The Response event will return an object of type ECMPGetNextObjectsResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileDelete(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileDeleteMessageRequest,ControlTechniques.CommsServer.FileDeleteMessageResponse@)">
            <summary>
            Delete a file on the target.
            
            The Response event will return an object of type FileDeleteMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileReadBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadBytesMessageRequest,ControlTechniques.CommsServer.FileReadBytesMessageResponse@)">
            <summary>
            Read the contents of a target file into an array of bytes.
            
            The Response event will return an object of type FileReadBytesMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileReadDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadDiskMessageRequest,ControlTechniques.CommsServer.FileReadDiskMessageResponse@)">
            <summary>
            Read the contents of a target file into a file on disk.
            
            The Response event will return an object of type FileReadDiskMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileIsWriteOnly(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageResponse@)">
            <summary>
            Check if the specified target file is write-only
            </summary>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name to check</param>
            <param name="response">The response.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileWriteBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest,ControlTechniques.CommsServer.FileWriteBytesMessageResponse@)">
            <summary>
            Write the contents of a target file from an array of bytes.
            
            The Response will be an object of type FileWriteBytesMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileWriteDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest,ControlTechniques.CommsServer.FileWriteDiskMessageResponse@)">
            <summary>
            Write the contents of a target file from a file on disk.
            
            The Response will be an object of type FileWriteDiskMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileList(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileListRequest,ControlTechniques.CommsServer.FileListResponse@)">
            <summary>
            Obtain a list of files in a given directory.
            
            The Response will be an object of type FileListResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileExists(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileExistsRequest,ControlTechniques.CommsServer.FileExistsResponse@)">
            <summary>
            Check if the specified target file exists.
            </summary>
            <remarks>
            The existence check can be done two ways: (1) By attempting to open the file, or (2) issuing a ECMP FileExists
            command. By default method 1 is used since many devices do not support FileExists command and so this method is more
            compatbile. However you can force method 2 to be used instead by specifying <see cref="P:ControlTechniques.CommsServer.FileExistsRequest.UseFileExistsCommand"/>=true.
            </remarks>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name to check</param>
            <param name="response">Response.</param>
            <returns>Response status of the request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.FileInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileInfoRequest,ControlTechniques.CommsServer.FileInfoResponse@)">
            <summary>
            Request information about a file such as its file length.
            </summary>
            <remarks>
            Not all tagets will support this command, and the which attributes are supported is also target and file location dependant.
            Certain targets may also impose a limit on how many attributes may be requested in one request. 
            </remarks>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name and the attributes to get.</param>
            <param name="response">Response.</param>
            <returns>Response status of the request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.GetSyncInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPSyncInfoRequest,ControlTechniques.CommsServer.ECMPSyncInfoResponse@)">
            <summary>
            Gets Sync Info
            </summary>
            <param name="address">address of drive from which to get sync info</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.CyclicLink(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase,ControlTechniques.CommsServer.ECMPCyclicLinkResponse@)">
            <summary>
            Get Cyclic Link Information
            </summary>
            <remarks>The new <seealso cref="M:ControlTechniques.CommsServer.BlockingCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase,ControlTechniques.CommsServer.ECMPCyclicLinkResponse@)"/> method should be used for newer targets adhearing to the V1.0 ECMP specification.</remarks>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase,ControlTechniques.CommsServer.ECMPCyclicLinkResponse@)">
            <summary>
            Get Cyclic Link Information
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.GetDiagnostics(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPDiagnosticRequest,ControlTechniques.CommsServer.ECMPDiagnosticResponse@)">
            <summary>
            Get Diagnostic Information
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <param name="response">response received</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.GetProgramStatus(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPProgramStatusRequest,ControlTechniques.CommsServer.ECMPProgramStatusResponse@)">
            <summary>
            Get the status of the user program
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.TransmitAndGetResponse``2(ControlTechniques.CommsServer.CommsAddress,``0,``1@)">
            <summary>
            Transmits request and receives response
            </summary>
            <typeparam name="TRequest">ECMPUserRequest to transmit</typeparam>
            <typeparam name="TResponse">ECMPUserResponse to receive</typeparam>
            <param name="address">address to transmit to</param>
            <param name="request">request to send</param>
            <param name="response">response to receive</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.WaitForResponse(System.Object@,ControlTechniques.CommsServer.T_RESPONSE_STATUS@)">
            <summary>
            After a transmission, this method should be called to wait for a response to be available.
            Note that the Response argument should only be used when a Status of OK is returned - for other
            statuses Response may be null.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.BlockingCommsUser.HandleMessageQueueResponse(ControlTechniques.CommsServer.MessageQueueRequest,ControlTechniques.CommsServer.MessageQueueResponse)">
            <summary>
            Invoke the subscribed events on their original threads.
            </summary>
            <param name="TheRequest"></param>
            <param name="TheResponse"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.BlockingCommsUser.FileTransferProgress">
            <summary>
            The progress of the current file transfer action
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.BlockingCommsUser.MaxTransmitBufferSizeBytes">
             <summary>
             Sets/gets the maximum number of bytes sent in a file transfer or tunneled frame.
             </summary>
             <remarks>
             An out-of-range value will be ignored (range 16-1000).
             
             The default value should be suitable in most cases. The value can be set to the <see cref="P:ControlTechniques.CommsServer.ECMPInfoResponse.BufferSizeBytes"/> obtained from the target.
            
             Note that file transfer (using <see cref="M:ControlTechniques.CommsServer.BlockingCommsUser.FileWriteDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest,ControlTechniques.CommsServer.FileWriteDiskMessageResponse@)"/> and <see cref="M:ControlTechniques.CommsServer.BlockingCommsUser.FileWriteBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest,ControlTechniques.CommsServer.FileWriteBytesMessageResponse@)"/>) automatically query the target device for its buffer size 
             and will use that value for the file transfer. To force the value of this property to be used instead specify the <see cref="F:ControlTechniques.CommsServer.FileWriteOptions.DisableAutoBufferSize"/> flag
             in the request.
             </remarks>
             <seealso cref="M:ControlTechniques.CommsServer.BlockingCommsUser.Info(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest,ControlTechniques.CommsServer.ECMPInfoResponse@)"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.BlockingCommsUser.IsActive">
            <summary>
            Returns whether the user is active, i.e. <see cref="M:ControlTechniques.CommsServer.BlockingCommsUser.Go(ControlTechniques.CommsServer.Protocol)"/> has been called.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.BlockingCommsUser.TheProtocol">
            <summary>
            Returns the protocol currently in use by the user. null may be
            returned if the user has not called Go (or has since called Stop).
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.BlockingCommsUser.T_USER_STATUS">
            <summary>
            Operation statuses.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode">
            <summary>
            Represents a Ethernet node that has been discovered but it may not be possible to communicate to it possibly due to
            it not being accessible via its IP address. This <i>could</i> mean that it is unconfigured.
            The node will have responded to a discovery request on the local subnet so usually it should also respond to normal eCMP queries too.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.INode">
            <summary>
            Interface to hold values for <see cref="T:ControlTechniques.CommsServer.CommsAddress"/> and <see cref="P:ControlTechniques.CommsServer.INode.Protocol"/> of a node 
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.INode.Address">
            <summary>
            The address to be used to communicate with the node.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.INode.InterfaceAddress">
            <summary>
            The address of the Ethernet port on the device if it has one. Will be null if no Ethernet interface is available.
            Note that this address will be different from <see cref="P:ControlTechniques.CommsServer.INode.Address"/> if the node can be reached via different routes or protocols.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.INode.Protocol">
            <summary>
            The protocol on which the node was discovered.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IUnconfiguredNode.TypeName">
            <summary>
            Type name as returned from the discovery protocol.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IUnconfiguredNode.Name">
            <summary>
            The user defined name for the node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode.#ctor(CTCOMMSSERVERLib.IUnconfiguredNode)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode"/> class.
            </summary>
            <param name="node">The node. </param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode.Set(System.String,System.String)">
            <summary>
            Writes various configuration parameters to the device by issuing a Discovery Protocol assign command.
            </summary>
            <remarks>
            The following properties are set:
            - DHCPEnabled, IPAaddress, Gateway, Netmask.
            
            The username and password may be required by some devices.
            </remarks>
            <param name="username">The username.</param>
            <param name="password">The password.</param>
            <returns>true if device accepted request, false otherwise.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode.TypeName">
            <summary>
            Type name as returned from the discovery protocol.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode.Name">
            <summary>
            The user defined name for the node.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode.Address">
            <summary>
            Get/sets the comms address.
            When setting, ensure address is an IP address.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode.InterfaceAddress">
            <summary>
            The address of the Ethernet port on the device, which will be the same as <see cref="P:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode.Address"/>.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredUnconfiguredNode.Protocol">
            <summary>
            The protocol on which the node was discovered.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkAttributeRequestBase">
            <summary>
            Base class for cyclic link request that feature a list of attributes
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase">
            <summary>
            Base class for cyclic link requests.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest"/>    
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkDeleteRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkEditRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkExistRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkFinaliseRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkGetLinkStateRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkGetMappingsRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkListRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase.#ctor(System.Int32)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase.ToBytes">
            <summary>
            Get the request as a sequence of bytes to embed into an eCMP request
            </summary>
            <returns>array of bytes</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase.UserRequestFromBytes(ControlTechniques.CommsServer.ECMPMessageRequestBase.T_MESSAGE_ID,System.Byte[],System.Int32@)">
            <summary>
            Recreate a request from bytes. 
            </summary>
            <param name="messageId">The ECMP message ID</param>
            <param name="b">Data buffer</param>
            <param name="from">Data buffer pointer.</param>
            <returns>Cyclic link message request or NULL if problem occured.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase.CyclicLinkNumber">
            <summary>
            Identifier for the Cyclic Link
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase.UseLegacyCommand">
            <summary>
            Set to <c>true</c> for the request to be made via the legacy CyclicLink command (0x31), otherwise with the default value of <c>false</c>
            the request will be sent using the newer CyclicLink2 command (0x33) as defined in ECMP specification V1.0.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkDirectionalRequestBase.FromBytes(ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE,System.Byte[],System.Int32@)">
            <summary>
            Recreates a request (0x33 type only).
            </summary>
            <param name="mode">The mode (sub-command)</param>
            <param name="b">Byte buffer</param>
            <param name="from">Buffer pointer.</param>
            <returns>Cyclic link command, or <c>null</c> if decode failed.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkAttributeRequestBase.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber"></param>
            <param name="linkDirection"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkAttributeRequestBase.Attributes">
            <summary>
            List of cyclic link attributes
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest">
            <summary>
            Create Cyclic Link Request
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.ToBytes">
            <summary>
            Convert request into sequence of bytes ready for embedding into an eCMP request
            </summary>
            <returns>array of bytes</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.Attributes">
            <summary>
            List of cyclic link attributes
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.MotionEngineCycleOffset">
            <summary>
            The offset in nanoseconds from the start of the motion cycle that data should be processed.  
            </summary>
            <remarks>
            This is the point received data should be written and transmitted data should be sampled.
            If not specified default value is 0.
            null if not present in the response data.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.RxTimeoutHandler">
            <summary>
            Rx Timeout Handler. Defines what action should be taken when data fails to be received.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.RxLateDataHandler">
            <summary>
            Rx Late Data Handler. Defines what action should be taken when data is received late (data was received after it should have been processed).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.TransportAddress">
            <summary>
            Transport Address. This is the address of the link source (for an RX link) or destination (for a TX link).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.MaxMappings">
            <summary>
            Maximum number of mappings. 
            </summary>
            <remarks>
            Can only be set during link creation.
            Not used when using the newer cyclic link interface (see <see cref="M:ControlTechniques.CommsServer.ASynchronousCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)"/>, <see cref="M:ControlTechniques.CommsServer.PollingCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)"/>, <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.CyclicLink(ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)"/>).
            </remarks>
            \deprecated This attribute is obsolete and should not be used.
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.MappingItems">
            <summary>
            A mapping item describes the source / destination of data to be mapped in to the process image.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.Saveable">
            <summary>
            Whether the link is persistent (true) or volatile (false)
            </summary>
            \deprecated This attribute is obsolete and should not be used.
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.SamplePeriod">
            <summary>
            The time between each sampling of cyclic data. For synchronised links this must be a 
            multiple of all receiving nodes motion cycle periods
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.MotionEngineCycleDelay">
            <summary>
            The offset from the start of the motion cycle the data was sampled in to the start 
            of the motion cycle the receiving data must use the data
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.LinkStatus">
            <summary>
            Status as defined by register 10.1. To clear status bits write to this register with corresponding bit set
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.LinkName">
            <summary>
            ASCII name for the link. Maximum length of string is 32 ASCII characters.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkCreateRequest.LinkTag">
            <summary>
            Tag used by configuration software to detect changes made to links once initialization of the 
            device and therefore its stored configuration has completed. Value shall be non-zero set by 
            configuration tool. Any further change shall set tag to zero.
            Tag value defaults to zero if not set.
            </summary>
            <remarks>
            This is different from the <see cref="P:ControlTechniques.CommsServer.ECMPUserRequest.Tag"/> property as that is only on PC
            side and does not form part of the cyclic link message.
            </remarks>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkDeleteRequest">
            <summary>
            Cyclic Link Delete Request
            </summary>
            <remarks>
            Delete the specified link configuration
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkDeleteRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkDeleteRequest.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkEditRequest">
            <summary>
            Cyclic Link Edit Request
            </summary>
            <remarks>
            Requests that the specified cyclic link be set into EDIT mode
            so that the user can use the set request to configure the link
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkEditRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkEditRequest.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkExistRequest">
            <summary>
            Request whether a cyclic link exists.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkExistRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber">Link number.</param>
            <param name="linkDirection">Link direction.</param>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkFinaliseRequest">
            <summary>
            Finalise Cyclic Link Request
            </summary>
            <remarks>
            Verify configuration and set to running
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkFinaliseRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber"></param>
            <param name="linkDirection"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkFinaliseRequest.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkGetMappingsRequest">
            <summary>
            Cyclic Link Request to Get Mappings
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkGetMappingsRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber"></param>
            <param name="linkDirection"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkGetMappingsRequest.ToBytes">
            <summary>
            Get the request as a sequence of bytes to embed into an eCMP request
            </summary>
            <returns>array of bytes</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkGetMappingsRequest.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkGetMappingsRequest.MaxMappings">
            <summary>
            Max mappings to return
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkGetMappingsRequest.StartOffset">
            <summary>
            Start Offset
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest">
            <summary>
            Cyclic Link Get Request. Used to read attributes of an existing cyclic link.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified link number and direction.
            The list of attributes to get are supplied in the <see cref="P:ControlTechniques.CommsServer.ECMPCyclicLinkAttributeRequestBase.Attributes"/> property. This list
            is pre-populated with most readable attributes so if you want to specify your own attribute list use the other constructor.
            </summary>
            <param name="cyclicLinkNumber">Link number.</param>
            <param name="linkDirection">Link direction.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION,System.Collections.ObjectModel.Collection{ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE})">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified link number, direction and required attributes.
            </summary>
            <param name="cyclicLinkNumber">Link number.</param>
            <param name="linkDirection">Link direction.</param>
            <param name="attributes">Attributes to get. Must be specified.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest.ToBytes">
            <summary>
            Get the request as a sequence of bytes to embed into an eCMP request
            </summary>
            <returns>array of bytes</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkGetRequest.Attributes">
            <summary>
            Attributes.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkGetLinkStateRequest">
            <summary>
            Lightweight request to return the state of a specified link number
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkGetLinkStateRequest.ToBytes">
            <summary>
            Get the request as a sequence of bytes to embed into an eCMP request
            </summary>
            <returns>array of bytes</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkGetLinkStateRequest.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkInfoRequest.#ctor">
            <summary>
            Create a cyclic link info request
            </summary>
            <remarks>
            Link number is not required for <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkInfoRequest"/>
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkInfoRequest.ToBytes">
            <summary>
            Get the request as a sequence of bytes to embed into an eCMP request
            </summary>
            <returns>array of bytes</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkInfoRequest.FromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstructs a request from bytes.
            </summary>
            <param name="b"></param>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkInfoRequest.Mode">
            <summary>
            Link Mode
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkInfoRequest.InfoAttributes">
            <summary>
            List of cyclic link info attributes
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkListRequest.#ctor">
            <summary>
            Link number is not required for <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkListRequest"/>
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkListRequest.FromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstructs a request from bytes.
            </summary>
            <param name="b"></param>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem">
            <summary>
            A mapping item describes the source / destination of data to be mapped in to the process image.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem.#ctor">
            <summary>
            Construct a cyclic data mapping item.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem.#ctor(System.Int32,ControlTechniques.CommsServer.ParameterAddress,System.String)">
            <summary>
            Construct a cyclic data mapping item.
            </summary>
            <param name="processImageOffset">Process image offset (range 0-255)</param>
            <param name="address">Source/destination address.</param>
            <param name="name">Optional name for the mapping item.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem.#ctor(System.Byte[],System.Int32@)">
            <summary>
            Constructs a <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem"/> from the specified data.
            </summary>
            <param name="data">data to construct the <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem"/> from.</param>
            <param name="from">index to start reading data from.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem.ToBytes">
            <summary>
            Convert to byte data representation for embedding into eCMP request
            </summary>
            <returns>array of bytes</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem.ProcessImageOffset">
            <summary>
            Process Image Offset
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem.ParameterAddress">
            <summary>
            Parameter Address
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkMappingItem.Name">
            <summary>
            Mapping name. Maximum string length is 32 characters.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkMessageRequest">
            <summary>
            Represents an eCMP Cyclic Link Request.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPMessageRequestBase">
            <summary>
            Base class for all eCMP messages. Internal use only.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPMessageRequestBase.mTimeouts">
            <summary>
            The comms timeouts for this process.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageRequestBase.SetTimeouts(ControlTechniques.CommsServer.CommunicationsTimeouts)">
            <summary>
            Set the timeouts for the process.
            </summary>
            <param name="TheTimeouts"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageRequestBase.Timeouts">
            <summary>
            Returns the communications timeout.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageRequestBase.#ctor">
            <summary>
            Constructor.
            </summary>
            <param name="destinationAddress">Address where to send message to.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageRequestBase.ToBytes">
            <summary>
            Return message as a byte array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageRequestBase.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageRequestBase.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageRequestBase.PostTxDelayMs">
            <summary>
            The default delay after transmission before a following transmission should take place.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageRequestBase.UserRequestFromBytes(ControlTechniques.CommsServer.ECMPMessageRequestBase.T_MESSAGE_ID,System.Byte[],System.Int32@)">
            <summary>
            Reconstructs a <see cref="T:ControlTechniques.CommsServer.ECMPUserRequest"/> object from a request buffer.
            </summary>
            <param name="messageId">The ECMP message id.</param>
            <param name="b">Buffer</param>
            <param name="from">Buffer pointer.</param>
            <returns>ECMP Message or <c>null</c> if decode not available. When null is returned you must not attempt any further decoding
            of the buffer.</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPMessageRequestBase.T_MESSAGE_ID">
            <summary>
            ECMP message IDs - requests.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkMessageRequest.MessageID">
            <summary>
            Gets the Message ID for this Message Request
            </summary>
            <returns>
            Message ID
            </returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkMessageRequest.ToBytes">
            <summary>
            Convert the request to byte format for sending in an eCMP format
            </summary>
            <returns>
            Array of bytes representing encoded request
            </returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkMessageRequest.Request">
            <summary>
            Request object
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkMessageResponse">
            <summary>
            Represents an eCMP Cyclic Link Response
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPMessageResponseBase">
            <summary>
            Base class for all eCMP messages.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPMessageResponseBase.#ctor">
            <summary>
            Constructor.
            </summary>
            <param name="destinationAddress">Address where to send message to.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPMessageResponseBase.TimeStamp">
            <summary>
            Timestamp when response was received.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPMessageResponseBase.T_MESSAGE_ID">
            <summary>
            ECMP message IDs - requests.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkMessageResponse.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkMessageResponse.CreateFrom(System.Byte[],System.Int32,System.Int32,ControlTechniques.CommsServer.ECMPMessageResponseBase.T_MESSAGE_ID)">
            <summary>
            Builds an <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkMessageResponse"/> from the supplied data.
            </summary>
            <param name="data">Data to build <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkMessageResponse"/> from.</param>
            <param name="from">Index in data to commence reading from.</param>
            <param name="length">Length of the payload.</param>
            <param name="messageId">The ECMP message ID - needed to differentiate between 0x31 and new 0x33 cyclic link format.</param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkMessageResponse.Response">
            <summary>
            Reponse object
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.Request">
            <summary>
            Originating request
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.Status">
            <summary>
            Status
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.ErrorIndex">
            <summary>
            Index of the attribute that has caused an error, or null if no error
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.Mode">
            <summary>
            The requested mode
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.SetAttributes">
            <summary>
            A list of attributes that have been successfully set, or null if not valid for request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.State">
            <summary>
            The current link state, or null
            </summary>
            <remarks>
            If not valid for this state or not present in the response data 
            then this property will be null.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.LinkDirection">
            <summary>
            Is this link configured for transmitting or receiving?
            </summary>
            <remarks>
            null if not present in the response data
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.Synchronised">
            <summary>
            Is this link synchronised to the motion cycle?
            </summary>
            <remarks>
            null if not present in the response data
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MotionEngineCycleOffset">
            <summary>
            The offset in nanoseconds from the start of the motion cycle that data should be processed.  
            </summary>
            <remarks>
            This is the point received data should be written and transmitted data should be sampled.
            If not specified default value is 0.
            null if not present in the response data.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.SamplePeriod">
            <summary>
            The time between each sampling of cyclic data. For synchronised links this must be a 
            multiple of all receiving nodes motion cycle periods
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MotionEngineCycleDelay">
            <summary>
            The offset from the start of the motion cycle the data was sampled in to the start 
            of the motion cycle the receiving data must use the data
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.DataChange">
            <summary>
            Only transmit data if it has changed
            </summary>
            <remarks>
            True if only transmit on change,
            False if always transmit
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.RxTimeoutHandler">
            <summary>
            Rx Timeout Handler
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.RxLateDataHandler">
            <summary>
            Rx Late Data Handler
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.TransportAddress">
            <summary>
            Transport Address
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MaxMappings">
            <summary>
            Maximum number of mappings. 
            </summary>
            <remarks>
            Can only be set during link creation.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.NumMappings">
            <summary>
            The current number of mappings specified
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MappingItems">
            <summary>
            A mapping item describes the source / destination of data to be mapped in to the process image.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.Saveable">
            <summary>
            Whether the link is persistent (true) or volatile (false)
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.Exists">
            <summary>
            Does the requested link exist?
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.TxLinks">
            <summary>
            Array of transmitting link numbers. For devices compliant to ECMP spec V1.0 this can be between 0 and 65535, for legacy devices it is limited to 0-255.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.RxLinks">
            <summary>
            Array of receiving link numbers. For devices compliant to ECMP spec V1.0 this can be between 0 and 65535, for legacy devices it is limited to 0-255.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MaxRxLinks">
            <summary>
            Maximum number of receive links possible in the system
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MaxTxLinks">
            <summary>
            Maximum number of transmit links possible in the system
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MaxMappingsPerLink">
            <summary>
            Maximum number of mappings that can be added to a link
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MaxSyncRxLinks">
            <summary>
            Maximum number of synchronous receive links possible in the system
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MaxSyncTxLinks">
            <summary>
            Maximum number of synchronous transmit links possible in the system
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.MaxMappingsPerSyncLink">
            <summary>
            Maximum number of mappings that can be added to a synchronous link
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.ProcessAtQueueDepth">
            <summary>
            The depth for the ‘Process At’ queue available to each synchronous receive link
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.BaseMotionEngineCyclePeriod">
            <summary>
            Base period of the Motion Engine Cycle in ns
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.LinkStatus">
            <summary>
            Status of the link.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.LinkName">
            <summary>
            Name of link for configuration software use.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.LinkTag">
            <summary>
            Tag for configuration software use.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.StatusCounters">
            <summary>
            Status counters for bits 1 to 31 defined by register 10.1. Counters will increment up to
            65000; if a device does not support a counter then 65535 will be returned. Any counter can
            be cleared with a write of any value.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.GlobalLinkStatus">
            <summary>
            Bitwise OR of all configured links LINK_STATUS (14) bits 1-31. Bit 0 is a bitwise AND of all
            bit 0 for all configured links. A 1 for bit 0 in the Global Link Status indicates all links
            are running. A write to this attribute of any value will clear the global link status AND
            ALL configured link status attributes (attribute LINK_STATUS (14)).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.ResetLinkStatusCounters">
            <summary>
            Any write to this attribute wshall cause all link status counters (attributes 18 to 48) to
            be cleared. A read shall always return 0.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.AppliedMecDelay">
            <summary>
            TX ONLY - MEC Delay value applied
            to transmission timestamp accounting for
            any synchronised task advancements and
            offsets
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.SynchronousRxMecOffset">
            <summary>
            A device may advance or retard the
            processing of synchornous recieve links.
            This attribute describes the magnitude in
            nanoseconds and direction (+ is advance,
            - is retard)
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkResponse.SynchronousTxMecOffset">
            <summary>
            A device may advance or retard the pro-
            cessing of synchornous transmit links.
            This attribute describes the magnitude in
            nanoseconds and direction (+ is advance,
            - is retard)
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkRxLateData">
            <summary>
            Represents data for the Rx Late Data Handler.
            </summary>
            <remarks>
            This class is immutable.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkRxLateData.#ctor(System.Byte[],System.Int32@)">
            <summary>
            Constructs a <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRxLateData"/> from the specified data.
            </summary>
            <param name="data">
            data to construct object from. 
            Must be at least 3 bytes, but can be more.
            The class will be constructed from just the first 3 bytes.
            </param>
            <param name="from">
            index to start reading data from.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the data is less than 3 bytes.
            </exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkRxLateData.ToBytes">
            <summary>
            Converts this object into its byte data representation ready for sending as part of an eCMP request.
            </summary>
            <returns>array of bytes</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkRxTimeout">
            <summary>
            Represents data for the Rx Timeout Handler.
            </summary>
            <remarks>
            This class is immutable.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkRxTimeout.#ctor(System.Byte[],System.Int32@)">
            <summary>
            Constructs an <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRxTimeout"/> from the specified data
            </summary>
            <param name="data">
            data to construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRxTimeout"/> from. 
            Must be at least 7 bytes, but can be more than that. 
            Only the first 7 bytes will be read.
            </param>
            <param name="from">
            start position in data buffer
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the data is less than 7 bytes. 
            The data must contain at least 7 bytes.
            </exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkRxTimeout.ToBytes">
            <summary>
            Converts this Rx Timeout Handler to its byte data representation ready for packing into an eCMP request
            </summary>
            <returns>byte array containing data</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest">
            <summary>
            Set attributes on a cyclic link. Link must be editable and only writeable attributes can be altered.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.#ctor(System.Int32,ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION)">
            <summary>
            Construct <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase"/> with specified Cyclic Link Number
            </summary>
            <param name="cyclicLinkNumber"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.Mode">
            <summary>
            Cyclic Link Mode for this request
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.Attributes">
            <summary>
            List of attributes whose value will be set
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.MotionEngineCycleOffset">
            <summary>
            The offset in nanoseconds from the start of the motion cycle that data should be processed.  
            </summary>
            <remarks>
            This is the point received data should be written and transmitted data should be sampled.
            If not specified default value is 0.
            null if not present in the response data.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.SamplePeriod">
            <summary>
            The time between each sampling of cyclic data. For synchronised links this must be a 
            multiple of all receiving nodes motion cycle periods
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.MotionEngineCycleDelay">
            <summary>
            The offset from the start of the motion cycle the data was sampled in to the start 
            of the motion cycle the receiving data must use the data
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.RxTimeoutHandler">
            <summary>
            Rx Timeout Handler. Defines what action should be taken when data fails to be received.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.RxLateDataHandler">
            <summary>
            Rx Late Data Handler. Defines what action should be taken when data is received late (data was received after it should have been processed).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.TransportAddress">
            <summary>
            Transport Address. This is the address of the link source (for an RX link) or destination (for a TX link).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.MappingItems">
            <summary>
            A mapping item describes the source / destination of data to be mapped in to the process image.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.Saveable">
            <summary>
            Whether the link is persistent (true) or volatile (false). This property is obsolete.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.DataChange">
            <summary>
            Only transmit data if it has changed
            </summary>
            <remarks>
            True if only transmit on change,
            False if always transmit
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.LinkStatus">
            <summary>
            Link status register. Set bits will get cleared on target.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.StatusCounters">
            <summary>
            Status counters for bits 1 to 31 defined by register 10.1. Counters will increment up to
            65000; if a device does not support a counter then 65535 will be returned. Any counter can
            be cleared with a write of any value.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.GlobalLinkStatus">
            <summary>
            Bitwise OR of all configured links LINK_STATUS (14) bits 1-31. Bit 0 is a bitwise AND of all
            bit 0 for all configured links. A 1 for bit 0 in the Global Link Status indicates all links
            are running. A write to this attribute of any value will clear the global link status AND
            ALL configured link status attributes (attribute LINK_STATUS (14)).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCyclicLinkSetRequest.ResetLinkStatusCounters">
            <summary>
            Any write to this attribute wshall cause all link status counters (attributes 18 to 48) to
            be cleared. A read shall always return 0.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPDiagnosticRequest">
            <summary>
            Diagnostic Request
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPDiagnosticRequest.#ctor(ControlTechniques.CommsServer.T_DIAGNOSTIC_MODE,System.Collections.Generic.IEnumerable{ControlTechniques.CommsServer.T_DIAGNOSTIC_ATTRIBUTE})">
            <summary>
            Constructs a Diagnostic Request
            </summary>
            <param name="mode">Mode for diagnostic request</param>
            <param name="attributes">attributes affected by request</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPDiagnosticRequest.ToBytes">
            <summary>
            Convert request into byte sequence to send
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticRequest.Mode">
            <summary>
            Diagnostic Request Mode
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticRequest.Attributes">
            <summary>
            Attributes affected by diagnostic request
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPDiagnosticResponse">
            <summary>
            Response to a diagnostic request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPDiagnosticResponse.#ctor">
            <summary>
            Private Default constructor. This means this response can only be created using the CreateFrom static method.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPDiagnosticResponse.CreateFrom(System.Byte[],System.Int32@)">
            <summary>
            Create an <see cref="T:ControlTechniques.CommsServer.ECMPDiagnosticResponse"/> from the specified byte array
            </summary>
            <param name="data">buffer to read from</param>
            <param name="from">positon in buffer</param>
            <returns>Constructed <see cref="T:ControlTechniques.CommsServer.ECMPDiagnosticResponse"/></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.Request">
            <summary>
            Request to which this is a response
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.DeviceStatus">
            <summary>
            eCMP Device Status
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.DeviceStatusFaulted">
            <summary>
            Is the device in a faulted state
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.DeviceStatusAlarmed">
            <summary>
            Is the device in an alarmed state
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.DeviceStatusRunning">
            <summary>
            Is the device in a running state
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.DeviceStatusConfigurationValid">
            <summary>
            Is the device reporting its configuration is valid?
            MCi refers to its SML file
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.DeviceStatusNetworkActive">
            <summary>
            Is the device reporting the network as active?
            
            If false then the attribute 13 (NETWORK_STATUS) provides further info as to why.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.CyclicRate">
            <summary>
            Number of cyclic messages for device received/transmitted per second. 
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.CyclicSummary">
            <summary>
            Number of cyclic messages for device received per second.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.NonCyclicRate">
            <summary>
            Number of non-cyclic messages for device received/transmitted per second.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.NonCyclicSummary">
            <summary>
            Number of non-cyclic messages for device received per second.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.LateMessageCount">
            <summary>
            Number of messages received after the ‘action on’ timestamp.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.TimeoutMessageCount">
            <summary>
            Number of timeout messages for non sync links
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortSummaryList">
            <summary>
            Received and transmitted bytes per second values for each port as a list
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.ErrorCount" -->
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortCountList">
            <summary>
            List of detailed count values for packets received and transmitted on the port.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.TaskInformation">
            <summary>
            Returns a list of tasks currently running on the NGA module
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.RuntimeStatus">
            <summary>
            Provides information on the runtime status
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.SystemStatus">
            <summary>
            Discribes the NGA module system state
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.RtmoeStateMachineTrace">
            <summary>
            Trace buffer for RTMoE state machine
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.NetworkStatus">
            <summary>
            Gets the network interface status
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.MessageSummary.Rx">
            <summary>
            Number of messages for device received per second.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.MessageSummary.Tx">
            <summary>
            Number of messages for device transmitted per second.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortMessageSummary.PortNumber">
            <summary>
            Physical port number, starting at 1 for external interfaces.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortMessageSummary.Rx">
            <summary>
            Number of bytes per second received.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortMessageSummary.Tx">
            <summary>
            Number of bytes per second transmitted.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.#ctor(System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructs the port details class
            </summary>
            <param name="portNumber"></param>
            <param name="rx64"></param>
            <param name="rx127"></param>
            <param name="rx255"></param>
            <param name="rx511"></param>
            <param name="rx1023"></param>
            <param name="rxMax"></param>
            <param name="rxCrcError"></param>
            <param name="rxMulticast"></param>
            <param name="rxBroadcast"></param>
            <param name="rxBytes"></param>
            <param name="txMulticast"></param>
            <param name="txBroadcast"></param>
            <param name="txBytes"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.PortNumber">
            <summary>
            Port Number
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.Rx64">
            <summary>
            Number of frames received in range
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.Rx127">
            <summary>
            Number of frames received in range
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.Rx255">
            <summary>
            Number of frames received in range
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.Rx511">
            <summary>
            Number of frames received in range
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.Rx1023">
            <summary>
            Number of frames received in range
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.RxMax">
            <summary>
            Number of frames received in range
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.RxCrcError">
            <summary>
            Number of frames received with CRC errors
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.RxMulticast">
            <summary>
            Number of multicast frames received
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.RxBroadcast">
            <summary>
            Number of broadcast frames received
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.RxBytes">
            <summary>
            Number of bytes received
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.TxMulticast">
            <summary>
            Number of multicast frames transmitted
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.TxBroadcast">
            <summary>
            Number of broadcast frames transmitted
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPDiagnosticResponse.PortDetails.TxBytes">
            <summary>
            Number of bytes transmitted
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPErrorMessageResponse">
            <summary>
            Internal class representing an error message response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPErrorMessageResponse.T_ERROR_TYPE">
            <summary>
            Error types.
            </summary>
            <devnotes>
            Note: This enum is really in the wrong place - it should either be at namespace scope or within the scope of the 
            ECMPErrorResponse, however moving it causes binary incompatiblity and therefore should be looked at in the future when
            any other major changes are done.
            </devnotes>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPErrorMessageResponse.T_ERROR_TYPE.REQUEST">
            <summary>
            The specified request is not supported.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPErrorMessageResponse.T_ERROR_TYPE.OPTION">
            <summary>
            The specified option is not supported.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPErrorMessageResponse.T_ERROR_TYPE.EMERGENCY">
            <summary>
            Device is producing an emergency message.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPErrorResponse">
            <summary>
            Indicates the target device returned an error. This may happen, for example, when the device does not support what was requested.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPErrorResponse.RequestID">
            <summary>
            The request ID.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPErrorResponse.Request">
            <summary>
            The request, if available.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPErrorResponse.Option">
            <summary>
            Option.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPErrorResponse.ErrorType">
            <summary>
            The error type.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileListMessageRequest">
            <summary>
            Request message for eCMP FileList.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileListMessageRequest.ToBytes">
            <summary>
            Return message as a byte array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileListMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileListMessageRequest.FileHandle">
            <summary>
            File handle.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileListMessageRequest.MaxItems">
            <summary>
            Maximum number of items to return.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileListMessageResponse">
            <summary>
            Response message for eCMP FileList message.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileListMessageResponse.CreateFrom(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Static method to create a response from the byte stream.
            </summary>
            <param name="Frame">Data frame</param>
            <param name="From">Data position</param>
            <param name="Length">Length of data.</param>
            <returns>A ECMPFileListMessageResponse object.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileListMessageResponse.Status">
            <summary>
            Status.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileListMessageResponse.Hash">
            <summary>
            Directory hash.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileListMessageResponse.DirectoryEntries">
            <summary>
            The directory entries for this request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileListMessageResponse.OK">
            <summary>
            Indicates if the response status was OK.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInterrogateMessageRequest">
            <summary>
            Interrogate mesasge. Used to identify what the device supports.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPInterrogateMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPInterrogateMessageRequest.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInterrogateMessageRequest.Request">
            <summary>
            The request.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInterrogateMessageResponse">
            <summary>
            Interrogate mesasge. Used to identify what the device supports.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInterrogateMessageResponse.Response">
            <summary>
            The request.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.InterrogateItemType">
            <summary>
            Type of item(s) to interrogate.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.InterrogateItemType.Command">
            <summary>
            Command request codes.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.InterrogateItemType.Options">
            <summary>
            Option codes.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInterrogateRequest">
            <summary>
            Interrogation request. Checks whether a device supports commands/options.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPInterrogateResponse"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPInterrogateRequest.#ctor(ControlTechniques.CommsServer.InterrogateItemType,System.Byte[])">
            <summary>
            Constructor.
            </summary>
            <param name="type">Item type</param>
            <param name="itemCodes">Items. See <see cref="P:ControlTechniques.CommsServer.ECMPInterrogateRequest.ItemCodes"/>.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInterrogateRequest.ItemType">
            <summary>
            Type of item that <see cref="P:ControlTechniques.CommsServer.ECMPInterrogateRequest.ItemCodes"/> will contain.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInterrogateRequest.ItemCodes">
            <summary>
            Item codes to interrogate. For ECMP commands, use the constants from <see cref="T:ControlTechniques.CommsServer.ECMPMessageRequestBase.T_MESSAGE_ID"/>.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInterrogateResponse">
            <summary>
            Response to an Interrogate request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPInterrogateResponse.#ctor(ControlTechniques.CommsServer.InterrogateItemType,ControlTechniques.CommsServer.ECMPInterrogateResponse.ItemSupport[])">
            <summary>
            Constructor.
            </summary>
            <param name="itemType">Item type.</param>
            <param name="itemsSupport">Items.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInterrogateResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInterrogateResponse.ItemType">
            <summary>
            Type of items requested.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInterrogateResponse.Items">
            <summary>
            Array of item support responses.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInterrogateResponse.ItemSupport">
            <summary>
            Item support info.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPInterrogateResponse.ItemSupport.ItemCode">
            <summary>
            Item code information was requested for
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPInterrogateResponse.ItemSupport.SupportCode">
            <summary>
            Item supported value (0=Not supported, 1=Supported 2-255=Reserved) 
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPSyncInfoRequest">
            <summary>
            Sync Info Request
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPSyncInfoRequest.ToBytes">
            <summary>
            Converts the request to a byte sequence to transmit
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPSyncInfoRequest.FromBytes(System.Byte[],System.Int32@)">
            <summary>
            Recreates a SyncInfoGet/Set request from a request buffer.
            </summary>
            <param name="b">Buffer</param>
            <param name="from">Buffer pointer.</param>
            <returns>Request or null if decode failed.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoRequest.Mode">
            <summary>
            Mode can be used for set and get the attribute information.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoRequest.Attributes">
            <summary>
            Collection of attributes to request
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.#ctor">
            <summary>
            Default Constructor
            </summary>
            <remarks>
            Creates a GET request with all attributes selected.
            To create an empty request use the <see cref="M:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.Empty"/> static method or pass null to the other constructor.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.Empty">
            <summary>
            Creates and empty get request. You will need to add the attributes you want using the <see cref="P:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.Attributes"/> property.
            </summary>
            <returns>An empty request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.#ctor(System.Collections.Generic.IEnumerable{ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE})">
            <summary>
            Creates a GET request with the requested attributes.
            </summary>
            <param name="attributes">Attributes. Null is accepted in which case the request attribute list will be empty and you can add items using the <see cref="P:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.Attributes"/> property.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.ToBytes">
            <summary>
            Converts this request to its byte sequence ready for transmission
            </summary>
            <returns>byte sequence</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.FromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstruct a request from bytes.
            </summary>
            <param name="b">Buffer.</param>
            <param name="from">Buffer pointer.</param>
            <returns>The request.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest.Attributes">
            <summary>
            Collection of attributes to GET
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramControlMessageResponse.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramControlMessageResponse.CreateFrom(System.Byte[],System.Int32)">
            <summary>
            Builds an <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkMessageResponse"/> from the supplied data.
            </summary>
            <param name="data">Data to build <see cref="T:ControlTechniques.CommsServer.ECMPCyclicLinkMessageResponse"/> from.</param>
            <param name="from">Index in data to commence reading from.</param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramControlMessageResponse.Response">
            <summary>
            Response object
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPProgramControlRequest">
            <summary>
            ECMP Message to control the state of a user program.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramControlRequest.#ctor">
            <summary>
            Default construction
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramControlRequest.#ctor(ControlTechniques.CommsServer.ProgramControl)">
            <summary>
            Construction with required program state
            </summary>
            <param name="control"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramControlRequest.ToBytes">
            <summary>
            Returns the required program control as a byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramControlRequest.FromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstructs a request from bytes.
            </summary>
            <param name="b"></param>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramControlRequest.Target">
            <summary>
            This field can be used to select a specific program to retrieve the status of.  
            A value of zero should select the default program; all other values are platform specific.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramControlRequest.ProgramControl">
            <summary>
            The required state of the user program
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramControlRequest.SubCommand">
            <summary>
            This field is used to select a specialised version of the required command. A value of zero should always select the default non-specialised implementation; all other values are platform specific.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPProgramControlResponse">
            <summary>
            Response to a program control request.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPProgramControlRequest"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramControlResponse.Request">
            <summary>
            The request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramControlResponse.Response">
            <summary>
            The response value.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramStatusMessageResponse.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramStatusMessageResponse.CreateFrom(System.Byte[],System.Int32)">
            <summary>
            Builds an <see cref="T:ControlTechniques.CommsServer.ECMPProgramStatusMessageResponse"/> from the supplied data.
            </summary>
            <param name="data">Data to build <see cref="T:ControlTechniques.CommsServer.ECMPProgramStatusMessageResponse"/> from.</param>
            <param name="from">Index in data to commence reading from.</param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramStatusMessageResponse.Response">
            <summary>
            Response object
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPProgramStatusRequest">
            <summary>
            Request for the status of the user program (i.e. is it Running, Stopped etc)
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramStatusRequest.#ctor">
            <summary>
            Default construction
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramStatusRequest.#ctor(System.Byte)">
            <summary>
            Construction specifying the target 
            </summary>
            <param name="target">This field can be used to select a specific program to retrieve the status of.  A value of zero should select the default program; all other values are platform specific.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPProgramStatusRequest.ToBytes">
            <summary>
            Returns the required program control as a byte array
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramStatusRequest.Target">
            <summary>
            This field can be used to select a specific program to retrieve the status of.  
            A value of zero should select the default program; all other values are platform specific.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPProgramStatusResponse">
            <summary>
            Response to the <see cref="T:ControlTechniques.CommsServer.ECMPProgramStatusRequest"/>
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramStatusResponse.Request">
            <summary>
            Original request
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPProgramStatusResponse.ProgramStatus">
            <summary>
            The current status of the user program (i.e. Running, Stopped, Exception) 
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPSyncInfoMessageRequest">
            <summary>
            Represents an eCMP Sync Info Request
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPSyncInfoMessageRequest.MessageID">
            <summary>
            Gets the Message ID for this Message Request
            </summary>
            <returns>
            Message ID
            </returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPSyncInfoMessageRequest.ToBytes">
            <summary>
            Convert the request to byte format for sending in an eCMP format
            </summary>
            <returns>
            Array of bytes representing enoded request
            </returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoMessageRequest.Request">
            <summary>
            Request object
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPSyncInfoMessageResponse">
            <summary>
            Represents an eCMP Sync Info response
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPSyncInfoMessageResponse.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPSyncInfoMessageResponse.CreateFrom(System.Byte[],System.Int32)">
            <summary>
            Create a response from the specified data
            </summary>
            <remarks>
            Please note that the response returned from this method is not actually populated until it's initial request is set back at a later point.
            At that stage the properties of the response are populated from the received data
            </remarks>
            <param name="frame">array of bytes containing data</param>
            <param name="from">start index of data within byte array</param>
            <returns>response</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoMessageResponse.Response">
            <summary>
            Response object
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPSyncInfoResponse">
            <summary>
            Sync Info Response
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPSyncInfoResponse.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPSyncInfoResponse.GetAttributeStatus(ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE)">
            <summary>
            Get the status for the specified attribute
            </summary>
            <param name="attribute">attribute to get status for</param>
            <returns>status, or <see cref="F:ControlTechniques.CommsServer.T_SYNC_INFO_STATUS.ATTRIBUTE_NOT_FOUND"/> if not found</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.Request">
            <summary>
            Originating request
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.Mode">
            <summary>
            Gets the mode of the original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.OverallStatus">
            <summary>
            Overall Status
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.AttributeInfo">
            <summary>
            The returned attributes and their status.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.SyncStatus">
            <summary>
            Sync Status
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.GrandmasterEUI">
            <summary>
            64bit Extended Unique Identifier specified by IEEE
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.MotionCycleTime">
            <summary>
            Motion cycle time in nS
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.JitterFromGM">
            <summary>
            Synchronisation jitter in ns
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.JitterThreshold">
            <summary>
            Tolerable clock jitter in ns from the grandmaster
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.PTPTime">
            <summary>
            Seconds since 1st Jan, 1970
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.ProtocolLayer">
            <summary>
            Protocol Layer
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.DelayMethod">
            <summary>
            Delay Method
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.OneStepTwoStep">
            <summary>
            1 step or 2 step
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.InhibitDriveSync">
            <summary>
            Controls whether the module synchronises the OPT_SYNC with the network grandmaster
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.PreferredSyncMaster">
            <summary>
            Module will be preferred as the grandmaster over others with higher preferred values or none specified
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.ClockDomain">
            <summary>
            Clock domain of the module
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.SyncStableWindow">
            <summary>
            Duration in milliseconds jitter must be below threshold for clock to be regarded as in sync.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPSyncInfoResponse.IsGrandMaster">
            <summary>
            Checks if the device is the current Grandmaster on the network
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.EcmpSyncInfoSetRequest.FromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstruct a request from bytes.
            </summary>
            <param name="b">Buffer.</param>
            <param name="from">Buffer pointer.</param>
            <returns>The request.</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ExplorerArgumentsInvalidException">
            <summary>
            Exception thrown when the <see cref="T:CTCOMMSSERVERLib.CTNetworkExplorerClass"/>.ExploreNetwork method 
            returns <see cref="!:enmExplorerStatus.ExplorerArgumentsInvalid"/>
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ExplorerInvalidProtocolException">
            <summary>
            Exception thrown when the <see cref="T:CTCOMMSSERVERLib.CTNetworkExplorerClass"/>.ExploreNetwork method 
            returns <see cref="!:enmExplorerStatus.ExplorerInvalidProtocol"/>
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest"/> class.
            </summary>
            <param name="targetFileName">Name of the target file.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest.TargetFileName">
            <summary>
            The target file name to access
            </summary>
            <value></value>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageResponse.#ctor(ControlTechniques.CommsServer.T_FILE_STATUS,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageResponse"/> class.
            </summary>
            <param name="fileStatus">The actual file status returned when the file open attempt was made, can be used to determine if the file was found etc.</param>
            <param name="request">The original request object.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageResponse.Request">
            <summary>
            The original request to which this is the response
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageResponse.FileIsWriteOnly">
            <summary>
            <c>True</c> if the file is write only, false otherwise
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageResponse.FileStatus">
            <summary>
            The actual file status returned when the file open attempt was made, can be used to determine if the file was found etc.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCompoundResponse">
            <summary>
            Response to a <see cref="T:ControlTechniques.CommsServer.ECMPCompoundRequest"/>. If all went ok there will be one response for each response status from the original
            request. Note that a response may be <c>null</c> if no data available.
            If a timeout of failure to transmit occurs then the status of the response will be set appropriately and only the responses successfully
            obtained will be returned.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCompoundRequest"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCompoundResponse.#ctor(ControlTechniques.CommsServer.ECMPCompoundRequest)">
            <summary>
            Constructor.
            </summary>
            <param name="theRequest"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCompoundResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCompoundResponse.Responses">
            <summary>
            List of responses. Note that a response may be null.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCompoundResponse.ResponseStatuses">
            <summary>
            List of response statuses.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPCompoundRequest">
            <summary>
            Compount request - a request built out of a list of other requests. Corresponding response is <see cref="T:ControlTechniques.CommsServer.ECMPCompoundResponse"/>.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPCompoundResponse"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPCompoundRequest.#ctor">
            <summary>
            Constructor. Initialises the <see cref="P:ControlTechniques.CommsServer.ECMPCompoundRequest.Requests"/> property with an empty list.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPCompoundRequest.Requests">
            <summary>
            List of requests.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DiscoveredDrive">
            <summary>
            Information about a drive discovered by the Network Explorer.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.NetworkExplorer"/>
        </member>
        <member name="T:ControlTechniques.CommsServer.DiscoveredNode">
            <summary>
            The base class for a node found by the NetworkExplorer class
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DiscoveredNode.#ctor(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Construct the node.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredNode.Address">
            <summary>
            The address to be used to communicate with the node.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredNode.InterfaceAddress">
            <summary>
            The address of the Ethernet port on the device if it has one.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredNode.Protocol">
            <summary>
            The protocol on which the node was discovered.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredNode.DiscoveredViaDIP">
            <summary>
            Was node discovered via discovery protocol.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.IDriveNode">
            <summary>
            Interface to describe a drive node, this can be a 
            <see cref="T:ControlTechniques.CommsServer.DiscoveredDrive"/> or an OfflineNode supplied by an IOfflineNodeProvider in the services assembly such as the virgo or CTAppProg
            project system.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IDriveNode.DriveType">
            <summary>
            The Drive Type - this is taken from the value of #11.063 in GT8
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IDriveNode.Derivative">
            <summary>
            The Drive Derivative. This is taken from #11.028 in GT8.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IDriveNode.FactoryFitOptionID">
            <summary>
            The Factory fit option ID. Values as yet undefined.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IDriveNode.OptionModules">
            <summary>
            The options on the drive.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IDriveNode.SerialNumber">
            <summary>
            Serial number of the discovered Drive.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IDriveNode.DriveName">
            <summary>
            Drive Name of the discovered drive
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IDriveNode.EntrySlotNumber">
            <summary>
            The slot number that has the comms interface for the drive's primary address.
            </summary>
            <remarks>
            E.g. for a M700 drive discovered via Ethernet connected to the front port of the drive the slot number will be 4.
            
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.IDriveNode.IsDuplicate">
            <summary>
            Indicates if this drive has already been found (based on serial number). Duplicate drives are removed from the discovery
            results at the end of the discovery process.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DiscoveredDrive.#ctor(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Construct the node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DiscoveredDrive.Equals(ControlTechniques.CommsServer.DiscoveredDrive)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.
                            </param>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredDrive.DriveType">
            <summary>
            The Drive Type - this is taken from the value of #11.063 in GT8
            </summary>
            <seealso cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.ProductType"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredDrive.Derivative">
            <summary>
            The Drive Derivative. This is taken from #11.028 in GT8.
            </summary>
            <seealso cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.DriveDerivative"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredDrive.FactoryFitOptionID">
            <summary>
            The Factory fit option ID.
            </summary>
            <seealso cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.OptionID"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredDrive.OptionModules">
            <summary>
            The options on the drive.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredDrive.SerialNumber">
            <summary>
            Serial number of the discovered Drive.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredDrive.DriveName">
            <summary>
            User Name of the discovered drive
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredDrive.EntrySlotNumber">
            <summary>
            The slot number that has the comms interface for the drive's primary address.
            </summary>
            <remarks>
            E.g. for a M700 drive discovered via Ethernet connected to the front port of the drive the slot number will be 4.
            
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredDrive.IsDuplicate">
            <summary>
            Indicates if this drive has already been found (based on serial number). Duplicate drives are removed from the discovery
            results at the end of the discovery process.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DiscoveredOption">
            <summary>
            Information about an option discovered by the Network Explorer.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IOptionNode.SlotID">
            <summary>
            The slot in which the option is fitted.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IOptionNode.OptionID">
            <summary>
            The option ID. This is taken from parameter X.01 in the option setup menu (15, 16 or 17 on GT8).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IOptionNode.DiscoveredViaDIP">
            <summary>
            Was node discovered via discovery protocol.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DiscoveredOption.#ctor(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)">
            <summary>
            Construct a discovered option.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredOption.SlotID">
            <summary>
            The slot in which the option is fitted.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DiscoveredOption.OptionID">
            <summary>
            The option ID. This is taken from parameter X.01 in the option setup menu (15, 16 or 17 on GT8).
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DirectoryEntryType">
            <summary>
            Type of directory item.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DirectoryEntryType.File">
            <summary>
            A file.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DirectoryEntryType.Directory">
            <summary>
            A directory.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DirectoryEntry">
            <summary>
            A directory entry.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DirectoryEntry.Type">
            <summary>
            Type of entry.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DirectoryEntry.Filename">
            <summary>
            The filename.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileListRequest">
            <summary>
            Request for a list of items within a directory. A kind of 'dir' command.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileListRequest.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.FileListRequest"/> class.
            </summary>
            <param name="directory">The directory to enumerate.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileListRequest.Directory">
            <summary>
            Directory to get file list from, e.g. "/fs".
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileListRequest.DirectoryHash">
            <summary>
            Optional directory hash to match against. If this is set and the target reports the same hash code
            then the file enumeration is stopped after the first message exchange with the target and the 
            <see cref="P:ControlTechniques.CommsServer.FileListResponse.DirectoryContentUnchanged"/> flag is set in the response. It is the responsibility of the
            client to cache the directory contents. This is an optimisation feature and should be left as null if not required.
            </summary>
            <remarks>Some targets may not support the hash.</remarks>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileListResponse">
            <summary>
            Response to a file list request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileListResponse.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.FileListResponse"/> class.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileListResponse.Status">
            <summary>
            Final status of the request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileListResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileListResponse.DirectoryHash">
            <summary>
            A hash of the directory contents.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileListResponse.DirectoryContentUnchanged">
            <summary>
            Indicates if the directory content is unchanged (i.e. the hash matches the hash given in the request).
            If this is set to true, the <see cref="P:ControlTechniques.CommsServer.FileListResponse.DirectoryEntries"/> hash will will be empty.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileListResponse.DirectoryEntries">
            <summary>
            A list of files and directories.
            If <see cref="P:ControlTechniques.CommsServer.FileListResponse.DirectoryContentUnchanged"/> is set true, this property should not be used.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileTransferProgressChangedEventArgs.#ctor(System.String,System.Int32,System.Int32,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.FileTransferProgressChangedEventArgs"/> class.
            </summary>
            <param name="targetFileName">Name of the target file.</param>
            <param name="fileSize">Size of the file.</param>
            <param name="bytesTransferred">The bytes transferred.</param>
            <param name="elapsedTime">Time elapsed.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileTransferProgressChangedEventArgs.FileSize">
            <summary>
            The total size of the file being read or written in bytes.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileTransferProgressChangedEventArgs.BytesTransferred">
            <summary>
            The number of bytes transferred thus far to or from the target
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileTransferProgressChangedEventArgs.TargetFileName">
            <summary>
            The target file name being accessed by the file transfer
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileTransferProgressChangedEventArgs.ProgressPercentage">
            <summary>
            The progress as a percentage
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileTransferProgressChangedEventArgs.ElapsedTime">
            <summary>
            Time elapsed.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.IPAddressRange">
            <summary>
            defines an IP address range
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.IPAddressRange.#ctor(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Constructs address range
            </summary>
            <param name="lower">lower end of range</param>
            <param name="upper">upper end of range</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.IPAddressRange.IsInRange(System.Net.IPAddress)">
            <summary>
            Is the specified IP Address within the defined range
            </summary>
            <param name="address">address to check</param>
            <returns>true if in range, false if not</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.IPAddressRange.LowerAddress">
            <summary>
            address that defines lower end of range
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.IPAddressRange.UpperAddress">
            <summary>
            address that defines the upper end of the range
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.MulticastRange">
            <summary>
            sub class of the IPAddressRange which is hard coded to represent the multicast IP range for IPv4
            </summary>
            <remarks>
            Information on the ip address range for multicast taken from
            http://en.wikipedia.org/wiki/Multicast_address
            </remarks>
        </member>
        <member name="T:ControlTechniques.CommsServer.LoopNodeState">
            <summary>
            Indicates the state of a node in the data loop.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.LoopNodeState.mState">
            <summary>
            The state of comms to the node.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.LoopNodeState.mStopwatch">
            <summary>
            The node's stopwatch.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.LoopNodeState.#ctor">
            <summary>
            Construct the state class with the hold off times.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.LoopNodeState.CommsSucceeded">
            <summary>
            Indicate comms has succeeded.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.LoopNodeState.CommsFailed">
            <summary>
            Indicate comms has failed.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.LoopNodeState.ShouldTalk">
            <summary>
            Indicates if comms to the node should be attempted.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.LoopNodeState.T_STATE">
            <summary>
            The node state.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.LoopNodeState.T_STATE.GOOD">
            <summary>
            Comms is successful.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.LoopNodeState.T_STATE.FAIL_ONE">
            <summary>
            We've had one comms failure since the last success.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.LoopNodeState.T_STATE.FAIL_TWO">
            <summary>
            We've had two comms failures since the last success.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.MessageQueue">
            <summary>
            Manages a list of messages for transmission.
            
            Each message is queued and actioned. Only when the first message has completed does the transmission
            of a later message begin.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mWindow">
            <summary>
            A proxy for handling Windows messages.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mMessages">
            <summary>
            The message queue. 
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mPortCommand">
            <summary>
            The command to the queue processing thread.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mQSemaphore">
            <summary>
            A semaphore used to indicate when something is waiting on the queue.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mWorker">
            <summary>
            The worker thread that does the transmission and reception.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mHandle">
            <summary>
            The Window handle for processing Windows messages on behalf of the rx/tx layer.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mEngine">
            <summary>
            The comms engine.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue._currentRequest">
            <summary>
            The current request being processed.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mLastTxDelay">
            <summary>
            The delay to implement after the last transmission.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue.mStopWatch">
            <summary>
            The stopwatch used to time post transmission delays.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.MessageQueue._cancelTransfer">
            <summary>
            Flag to cancel any active file transfer.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.BytesFrom(System.Byte[],System.Int32@,System.Int32)">
            <summary>
            Copies a set of bytes from the input to the output.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.OpenFile(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.T_FILE_MODE,System.String,ControlTechniques.CommsServer.T_RESPONSE_STATUS@,ControlTechniques.CommsServer.T_FILE_STATUS@,System.Int32@)">
            <summary>
            Opens a file.
            </summary>
            <param name="address"></param>
            <param name="mode">Specify, typically READ or CREATE (write).</param>
            <param name="filename">Filename to open</param>
            <param name="responseStatus">The response status.</param>
            <param name="fileStatus">The file status. If the request failed this will return FAIL_UNINITIALIZED.</param>
            <param name="fileHandle">Opened file handle.</param>
            <returns><c>true</c> if file opened and response status is OK.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.CloseFile(ControlTechniques.CommsServer.CommsAddress,System.Int32)">
            <summary>
            Close a file without providing CRC/Length check data - typically use this when aborting.
            </summary>
            <param name="address">Comms address.</param>
            <param name="fileHandle">File handle.</param>
            <returns><c>true</c> if file was closed *disregarding* a length/CRC error. <c>false</c> means file may not have been closed perhaps due to an invalid file handle.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.CloseFile(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,System.UInt32,ControlTechniques.CommsServer.T_RESPONSE_STATUS@,ControlTechniques.CommsServer.T_FILE_STATUS@)">
            <summary>
            Close a open file handle.
            </summary>
            <param name="address">Address</param>
            <param name="fileHandle">File handle number</param>
            <param name="len">Length of data received.</param>
            <param name="crc">CRC of data recevied.</param>
            <param name="status">Returned response status.</param>
            <param name="fileStatus">Returned file status.</param>
            <returns>True if the response was OK (in practice this means a OK response status and a file status of OK/OK_EOF/OK_MORE_DATA).</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.FileIsWriteOnly(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageResponse@)">
            <summary>
            Checks if the target file is write-only
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.ReadFileBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPUserRequest,System.Byte[]@,System.String,ControlTechniques.CommsServer.T_FILE_STATUS@,System.TimeSpan@)">
            <summary>
            Reads an array of bytes from a target file.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.FolderCreate(ControlTechniques.CommsServer.CommsAddress,System.String,ControlTechniques.CommsServer.T_FILE_STATUS@)">
            <summary>
            Create a folder on the target
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.WriteFileBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPUserRequest,System.Byte[],System.String,ControlTechniques.CommsServer.FileWriteOptions,ControlTechniques.CommsServer.MessageQueue.SendFileTransferProgressChangedNotificationDelegate,ControlTechniques.CommsServer.T_FILE_STATUS@,System.TimeSpan@)">
            <summary>
            Writes an array of bytes to a target file.
            </summary>
            <param name="address"></param>
            <param name="fileName"></param>        
            <param name="request"></param>
            <param name="options"></param>
            <param name="notificationDelegate">Who to call to notify of progress. If null given then it defaults to <see cref="M:ControlTechniques.CommsServer.MessageQueue.SendFileTransferProgressChangedNotification(ControlTechniques.CommsServer.ECMPUserRequest,System.Int32,System.Int32,System.TimeSpan)"/></param>
            <param name="fileStatus"></param>
            <param name="elapsedTime"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.DeleteFile(ControlTechniques.CommsServer.CommsAddress,System.String,ControlTechniques.CommsServer.T_FILE_STATUS@)">
            <summary>
            Deletes a file on the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.ListFiles(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileListRequest,ControlTechniques.CommsServer.FileListResponse@)">
            <summary>
            Reads a directory list on the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.FileExists(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileExistsRequest,ControlTechniques.CommsServer.FileExistsResponse@)">
            <summary>
            Fallback for checking if a file exists for use with targets that don't support the FileExists ECMP command.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.FileInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileInfoRequest,ControlTechniques.CommsServer.FileInfoResponse@)">
            <summary>
            Fallback for checking if a file exists for use with targets that don't support the FileExists ECMP command.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.TunnelFrame(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.TunnelFrameRequest,ControlTechniques.CommsServer.TunnelFrameResponse@)">
            <summary>
            Tunnels (chunking if needed) a tunnelled frame to/ from a device.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.DelayPostFileWrite">
            <summary>
            Implement any required delay after closure of a written file.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.HandleCompoundRequests(ControlTechniques.CommsServer.CommsAddress,System.Object,ControlTechniques.CommsServer.ECMPUserResponse@,ControlTechniques.CommsServer.T_RESPONSE_STATUS@)">
            <summary>
            Handle compound message requests - file/ tunnel. Compound request are those that may require a series of send/ receive messages e.g.
            to transmit a file as a series of chunks of data.
            </summary>
            <param name="Request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.ConstructMessage(ControlTechniques.CommsServer.ECMPUserRequest)">
            <summary>
            Construct a message for transmission based on the contents of a message queue request.
            </summary>
            <param name="Request">The user request.</param>
            <returns>The message to be transmitted.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.HandleResponse(ControlTechniques.CommsServer.ECMPMessageResponseBase,ControlTechniques.CommsServer.ECMPUserRequest,ControlTechniques.CommsServer.ECMPUserResponse@,ControlTechniques.CommsServer.T_RESPONSE_STATUS@)">
            <summary>
            Handle a message response and return a user response and status.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.SendFileTransferProgressChangedNotification(ControlTechniques.CommsServer.ECMPUserRequest,System.Int32,System.Int32,System.TimeSpan)">
            <summary>
            Sends the file transfer progress changed notification.
            </summary>
            <param name="request">The original file transfer request object.</param>
            <param name="fileSize">Size of the file being read or written.</param>
            <param name="bytesTransferred">The bytes transferred to/from the target so far.</param>
            <param name="elapsedTime">Elapsed time</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.SendResponseNotification(ControlTechniques.CommsServer.MessageQueueRequest,ControlTechniques.CommsServer.ECMPUserResponse,ControlTechniques.CommsServer.T_RESPONSE_STATUS)">
            <summary>
            Send a response notification to the client.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.DelayPostMessage(ControlTechniques.CommsServer.ECMPMessageRequestBase)">
            <summary>
            Implement any required delay after closure of a written file.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.ProcessRequest(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPUserRequest,ControlTechniques.CommsServer.ECMPUserResponse@,ControlTechniques.CommsServer.T_RESPONSE_STATUS@)">
            <summary>
            Works out what the request is and actions it. Returns true if the request is recognisable and
            can be actioned, false otherwise.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.mWorker_DoWork(System.Object,System.ComponentModel.DoWorkEventArgs)">
            <summary>
            Run the comms.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.FindMessageFromRequest(ControlTechniques.CommsServer.ECMPUserRequest)">
            <summary>
            Finds the message from request.
            </summary>
            <param name="request">The request.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.AddMessage(ControlTechniques.CommsServer.MessageQueueRequest)">
            <summary>
            Add a message to the queue.
            </summary>
            <param name="TheMessage"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.ClearMessages">
            <summary>
            Clears all messages in the queue.
            </summary>
            <param name="TheMessage"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.GetMessage(ControlTechniques.CommsServer.MessageQueueRequest@)">
            <summary>
            Gets a message from the queue. null is returned if there is no message.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.Go(ControlTechniques.CommsServer.Protocol)">
            <summary>
            Start the server.
            </summary>
            <param name="TheProtocol"></param>
            <param name="ComPort"></param>
            <param name="TheBaudRate"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.Stop(System.Boolean)">
            <summary>
            Stop the comms.
            </summary>
            <param name="wait">Set to <c>true</c> to wait for the worker thread to finish. Normally this is not required.
            Note that this does an <see cref="M:System.Windows.Forms.Application.DoEvents"/> that could cause issues under certain circumstances.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.mEngine_ECMPFail(ControlTechniques.CommsServer.ECMPTxRxLayer,ControlTechniques.CommsServer.ECMPTxRxLayer.T_FAIL_TYPE)">
            <summary>
            Handle a Comms timeout.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.mEngine_ECMPResponse(ControlTechniques.CommsServer.ECMPTxRxLayer,ControlTechniques.CommsServer.ECMPMessageResponseBase)">
            <summary>
            Handle a received message.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueue.CancelFileTransfer(ControlTechniques.CommsServer.ICommsUser)">
            <summary>
            Signals an active file transfer to cancel.
            </summary>
            <param name="user">Pass in the comms user that was issued the file transfer request.
            This ensure that only the comms user that issued the request can cancel it.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ControlTechniques.CommsServer.MessageQueue.GetMaxTransmitBufferSizeForCurrentRequest(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)" -->
        <member name="M:ControlTechniques.CommsServer.MessageQueue.TransmitAndGetResponse``1(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPMessageRequestBase,``0@)">
            <summary>
            Transmit a request and wait for the response.
            </summary>
            <param name="address">Address.</param>
            <param name="message">Message request to transmit.</param>
            <param name="response">Returned response of type T. If the returned status is OK then this is guaranteed not to be null.</param>
            <returns>Response status.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.MessageQueue.FormHandler">
            <summary>
            Set the comms window.
            </summary>
            <param name="Handler"></param>
        </member>
        <member name="T:ControlTechniques.CommsServer.MonitoredTask">
            <summary>
            Class that provides information on task resources on the NGA module
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MonitoredTask.Parse(System.Byte[])">
            <summary>
            Converts the raw bytes to a monitored task
            </summary>
            <param name="rawData"></param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.MonitoredTask.TaskID">
            <summary>
            The task the information refers to
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.MonitoredTask.FreeResource">
            <summary>
            Free resources available in % for this task.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.MonitoredTask.FreeResourceWorstCase">
            <summary>
            Worst Case of Free resources available in % for this task.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.NodeDiscoveredEventArgs">
            <summary>
            The event information when a node is discovered.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NodeDiscoveredEventArgs.#ctor(ControlTechniques.CommsServer.DiscoveredNode)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NodeDiscoveredEventArgs.Node">
            <summary>
            The node information.
            
            This can be cast to a DiscoveredDrive object.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.LookingForNodeEventArgs">
            <summary>
            The event information when the explorer begins looking for a node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.LookingForNodeEventArgs.#ctor(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.LookingForNodeEventArgs.Protocol">
            <summary>
            The protocol on which the node has been found.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.LookingForNodeEventArgs.Address">
            <summary>
            The node address.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.LookingOnNetworkEventArgs">
            <summary>
            The event information when the explorer begins looking on a network interface
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.NetworkExplorer">
            <summary>
            Network explorer is used to discover drives connected to the PC via serial communications or Ethernet.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer.TargetIdFFEthernet">
            <summary>
            Target ID for the factory fit ethernet option.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer.TargetIdMCi210">
            <summary>
            Target ID for the MCi210 option.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer.TargetIdSiEthernet">
            <summary>
            Target ID for the SI-Ethernet option
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer.SMEthernetName">
            <summary>
            Name of SM-Ethernet nodes - used to ignore them when the come back as unconfigured nodes.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer.Gt8ProductFamily">
            <summary>
            Drive specific constants used for enhanced node identification (wink) of LCD keypad backlights.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._asynOperation">
            <summary>
            Used to cache the thread of the constructor.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._arguments">
            <summary>
             The current explorer arguments.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._runCommanded">
            <summary>
            Is the explorer commanded to run?
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._stopAsyncCommanded">
            <summary>
            Has an stop been requested (asynchronous)?
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._isRunning">
            <summary>
            Is it actually running?
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._worker">
            <summary>
            The explorer thread.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._drives">
            <summary>
            The list of discovered drives and options.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._drivesBySerial">
            <summary>
            Discovered drives grouped by serial number (used for duplication testing)
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._unconfiguredNodes">
            <summary>
            List of unconfigured ethernet nodes found.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._commsUser">
            <summary>
            The comms user.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._messageLoopThread">
            <summary>
            Thread with message pump used to run the BlockingCommsUser in.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._lockObject">
            <summary>
            Object used to lock against multiple instances.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.NetworkExplorer._keypadFlashActiveAddresses">
            <summary>
            Keypad backlight flash (identify/wink) active addresses.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.AddNode(ControlTechniques.CommsServer.DiscoveredNode)">
            <summary>
            Adds a node to the list of discovered nodes.
            </summary>
            <param name="Node"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.StopSync">
            <summary>
            Stop the network explorer and wait for it to stop.
            </summary>
            <remarks>
            This call will block until the explorer has stopped.
            Note that the various events such as <see cref="E:ControlTechniques.CommsServer.NetworkExplorer.NodeDiscovered"/> may still fire and the <see cref="E:ControlTechniques.CommsServer.NetworkExplorer.NodeDiscoveryComplete"/> will fire when the
            results obtained so far are available and the explorer has stopped. 
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.Stop">
            <summary>
            Request to stop the network explorer.
            </summary>
            <remarks>
            This call will return immediately and the network browser will stop at the next opportunity.
            The <see cref="E:ControlTechniques.CommsServer.NetworkExplorer.NodeDiscoveryComplete"/> event will be fired when the explorer has finally stopped and nodes detected so far may be available.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.Go(ControlTechniques.CommsServer.NetworkExplorerArguments)">
            <summary>
            Run the explorer.
            </summary>
            <param name="Arguments"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.NodeIdentifyRequest(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Issue a request for a node to identify itself (usually by flashing the ethernet port lights).
            </summary>
            <param name="targetAddress">MAC address of node.</param>
            <param name="adapter">MAC address of the adapter to use. Specify null for automatic selection.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.NodeIdentifyRequest(System.Net.IPAddress,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Issue a request for a node to identify itself (usually by flashing the Ethernet port lights).
            For some devices if an LCD keypad is fitted then the backlight for the keypad will also be flashed.
            </summary>        
            <param name="targetAddress">IP address of node.</param>
            <param name="adapter">MAC address of the adapter to use. Specify null for automatic selection.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.NodeIdentifyRequest(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Issue a request for a node to identify itself (usually by flashing the Ethernet port lights).
            This method will also attempt to flash the backlight of any fitted keypads on supported drive types,
            and may be used with the RTU protocol.
            </summary>
            <param name="protocol">The protocol. Required if RTU node address, otherwise may be null.</param>
            <param name="address">The comms address of the node to identify.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.FlashKeypadBacklightAsync(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Enhanced node identification ("wink") which, if given a GT8 or Olympian type drive, will look to see if a LCD keypad is fitted
            (local and/or remote) and will attempt to flash the backlight of the keyapd.
            </summary>
            <remarks>
            Calling this kicks off a background thread that does the work.
            </remarks>
            <param name="protocol">Protocol.</param>
            <param name="address">The comms address.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.DiscoverDrive(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Discovers an ECMP device on a given address.
            This may be used to constract a <see cref="T:ControlTechniques.CommsServer.DiscoveredDrive"/> object without running through a full explore.
            </summary>
            <remarks>
            No events are raised in this method.
            </remarks>
            <param name="protocol">The protocol.</param>
            <param name="commsAddress">Comms address. (It will be modified to address the drive on slot 0 if required).</param>
            <returns><c>null</c> if no ECMP device discovered on the given address.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.OnWorkerCompleted(System.Object,System.ComponentModel.RunWorkerCompletedEventArgs)">
            <summary>
            The discovery process is complete.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.IndicateLookingForNode(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Tell subscribers we're looking for a specific node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.NewNodeDiscovered(ControlTechniques.CommsServer.DiscoveredNode)">
            <summary>
            Tell subscribers about the new node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.IndicateLookingOnNetwork(System.Net.NetworkInformation.NetworkInterface)">
            <summary>
            Tell subscribers we're looking for a specific node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.ExploreEthernet">
            <summary>
            Find nodes on Ethernet.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.GetFormattedPhysicalAddressString(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Return a MAC address as a string in the format of "AA:BB:CC:DD:EE:FF".
            </summary>
            <param name="physicalAddress">The physical MAC address.</param>
            <returns>Formatted string.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.RequiredComPorts">
            <summary>
            The COM ports on which to search, taken from the explorer arguments.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.GetMinRTUNode">
            <summary>
            The minimum RTU node to look for.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.GetMaxRTUNode">
            <summary>
            The maximum RTU node to look for.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.GetOptionInformation(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.DiscoveredDrive,CTCOMMSSERVERLib.INode2)">
            <summary>
            Gets the option information for a drive node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.IsEthernetNode(System.Int32)">
            <summary>
            Returns true if a node ID is recognised as being one that supports an Ethernet interface.
            This ID should be taken from the option setup menu parameter 1 (e.g. 17.001)
            </summary>
            <param name="nodeId">The node identification code.</param>
            <returns>True if node supports a standard ethernet interface.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.IsECMPNode(CTCOMMSSERVERLib.enmNodeTypes)">
            <summary>
            Returns true if the node type looks to be an ECMP type target.
            </summary>
            <param name="nodeType">Node Type from CommsServer</param>
            <returns>true if ECMp node.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.GetEthernetParameters(ControlTechniques.CommsServer.CommsAddress@)">
            <summary>
            Gets the Ethernet parameters for a given comms address from the common menu 2 parameters.
            </summary>
            <param name="address">Comms address of node to query.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.LookOnComPortAtBaudRate(System.Int32,ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE,ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Look for a node on a specific COM port at a specific baud rate.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.ExploreRTU">
            <summary>
            Find nodes on RTU.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.WorkerDoWork(System.Object,System.ComponentModel.DoWorkEventArgs)">
            <summary>
            The explorer thread.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.FindAndDeleteDuplicates">
            <summary>
            Finds any discovered drives that are duplicate and removes them.
            Duplicate nodes may occur if the same drive is found via say RTU and Ethernet or if the PC has two Ethernet connections to the same subnet.
            The drive's serial number is used for duplicate detection.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.UpdateEntryPointInfo(ControlTechniques.CommsServer.DiscoveredDrive)">
            <summary>
            Updates the comms entry point slot number on the drive (i.e. indicates which slot has the comms interface we're using
            as the primary address).
            </summary>
            <param name="drive"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorer.#ctor">
            <summary>
            Constructs an (inactive) explorer.
            </summary>
        </member>
        <member name="E:ControlTechniques.CommsServer.NetworkExplorer.NodeDiscovered">
            <summary>
            An event fired when a node has been discovered and all required information obtained,
            e.g. if a drive is discovered, this event will only get fired when all option information
            has been obtained and attached to the drive node object.
            </summary>
            <remarks>
            If a device is accessible via different addresses then this event will be raised for each address
            unless you set the <see cref="P:ControlTechniques.CommsServer.NetworkExplorerArguments.SuppressNodeDiscoveredEventForDuplicates"/>.
            Duplicates are determined by comparing the serial number of the drive/base device.
            </remarks>
        </member>
        <member name="E:ControlTechniques.CommsServer.NetworkExplorer.LookingForNode">
            <summary>
            An event fired when the explorer begins to look for a specific node.
            </summary>
        </member>
        <member name="E:ControlTechniques.CommsServer.NetworkExplorer.NodeDiscoveryComplete">
            <summary>
            This event is fired when node discovery is complete. This event MAY NOT be fired if
            the Stop method is called.
            </summary>
        </member>
        <member name="E:ControlTechniques.CommsServer.NetworkExplorer.LookingOnNetwork">
            <summary>
            This event is fired when we are searching Ethernet and we start looking on a specific network interface
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorer.NumberOfNodes">
            <summary>
            Returns the count of discovered node, i.e. the top level, primary nodes such as drives. The
            count does not include any options on drives.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorer.DiscoveredNodes">
            <summary>
            Returns the list of discovered nodes.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorer.DiscoveredUnconfiguredNodes">
            <summary>
            Returns a list of discovered but unreachable Ethernet nodes.
            </summary>
            <remarks>
            These are devices that have responded to the discovery UDP request but can't be communicated to with ECMP. This could be due to them
            not have their IP address or subnet set correctly.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorer.Arguments">
            <summary>
            Get the current arguments.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorer.Running">
            <summary>
            Is the explorer running?
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.NetworkExplorerArguments">
            <summary>
            The arguments for the Network Explorer.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.NetworkExplorer"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorerArguments.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.NetworkExplorerArguments"/> class. 
            This defaults the explorer arguments to search on all protocols (Ethernet and RTU) on all network interfaces for Ethernet and 
            on RTU look on all available COM ports and baud rates but only for nodes 1 to 5.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorerArguments.#ctor(ControlTechniques.CommsServer.NetworkExplorerRTUArguments)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.NetworkExplorerArguments"/> class for discovering on RTU only.
            </summary>
            <param name="rtuArguments">The RTU protocol arguments.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorerArguments.#ctor(ControlTechniques.CommsServer.NetworkExplorerEthernetArguments)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.NetworkExplorerArguments"/> class for discovering on Ethernet only.
            </summary>
            <param name="ethernetArguments">Arguments for Ethernet discovery.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorerArguments.#ctor(ControlTechniques.CommsServer.NetworkExplorerArguments.T_EXPLORE,ControlTechniques.CommsServer.NetworkExplorerRTUArguments,ControlTechniques.CommsServer.NetworkExplorerEthernetArguments)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.NetworkExplorerArguments"/> class with the given options.
            </summary>
            <param name="onProtocol">The protocol(s) to search on.</param>
            <param name="rtuArguments">RTU protocol arguments.</param>
            <param name="ethernetArguments">Ethernet protocol arguments.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorerArguments.OnProtocol">
            <summary>
            The protocol on which to look for nodes.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorerArguments.RTUArguments">
            <summary>
            This property is used to provide specific search criteria for RTU. It can be set to null
            (the default) to carry out a default scan - all available COM ports, all supported baud rates
            and from RTU node 1 to 5.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorerArguments.EthernetArguments">
            <summary>
            Holds the settings used for performing an ethernet scan
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorerArguments.SuppressNodeDiscoveredEventForDuplicates">
            <summary>
            If set, then the <see cref="E:ControlTechniques.CommsServer.NetworkExplorer.NodeDiscovered"/> event won't be raised when drive with the same serial number is 
            discovered again.
            </summary>
            <remarks>Note that the drive will still be added to the results set but may be removed at the end of discovery when duplicate
            resolution occurs (which may remove any of the duplicates).</remarks>
        </member>
        <member name="T:ControlTechniques.CommsServer.NetworkExplorerArguments.T_EXPLORE">
            <summary>
            The protocol on which to look for nodes.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.NetworkExplorerEthernetArguments">
            <summary>
            Ethernet protocol discovery arguments.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorerEthernetArguments.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.NetworkExplorerEthernetArguments"/> class.
            This constructor populates the <see cref="P:ControlTechniques.CommsServer.NetworkExplorerEthernetArguments.NetworkInterfaces"/> list with all available Ethernet interfaces that are up.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorerEthernetArguments.#ctor(System.Net.NetworkInformation.NetworkInterface)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.NetworkExplorerEthernetArguments"/> class for searching on single network interface.
            </summary>
            <param name="networkInterface">The network interface to search on.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorerEthernetArguments.NetworkInterfaces">
            <summary>
            List of Network Interfaces to use when performing discovery.
            If the parameter-less constructor is used, this list will be populated with all applicable network adapters.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.NetworkExplorerRTUArguments">
            <summary>
            This class is used to provide specific search criteria for RTU.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NetworkExplorerRTUArguments.#ctor">
            <summary>
            Construct the arguments with default properties:
                Search on all available COM ports.
                Search on all supported baud rates.
                Search for nodes 1 to 5.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorerRTUArguments.FromRTUNode">
            <summary>
            The minimum RTU node for which to scan - the default is 1.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorerRTUArguments.ToRTUNode">
            <summary>
            The maximum RTU node for which to scan - the default is 5.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.NetworkExplorerRTUArguments.ComPorts">
            <summary>
            COM Ports to explore on. 
            If not set (i.e. null, which is the default) then all COM ports will be scanned, otherwise
            only the ports listed will be scanned. IMPORTANT: If the list is empty then no ports will be scanned.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.COMPort">
            <summary>
            Struct containing information about a specific serial COM port.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.NetworkExplorer"/>
            <seealso cref="T:ControlTechniques.CommsServer.NetworkExplorerRTUArguments"/>
        </member>
        <member name="F:ControlTechniques.CommsServer.COMPort.PortNumber">
            <summary>
            COM port number, e.g. 1 means COM1.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.COMPort.BaudRate">
            <summary>
            Baud Rate. When using <see cref="T:ControlTechniques.CommsServer.NetworkExplorer"/> if this is set to null then all baudrates will be scanned if possible,
            otherwise only this baudrate will be scanned.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.Settings.GeneralSettings">
            <summary>
            Provides static access to per-user settings. These are intended to be used to disable or alter certain functionallity
            for dignostics/debugging purposes.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.Settings.GeneralSettings.regOptionsPath">
            <summary>
            Path to where options are stored in the per-user registry.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Settings.GeneralSettings.IsSet(System.String)">
            <summary>
            Checks if named setting is set - that is the registry option exists and has a value of 1.
            This does a registry read each time (value is not cached).
            </summary>
            <param name="optionName">Name of option</param>
            <returns>True if option is set (indicated by a DWORD value of 1 or higher).</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Settings.GeneralSettings.GetValue(System.String,System.Int32)">
            <summary>
            Returns an integer value.
            This does a registry read each time (i.e. value is not cached).
            </summary>
            <param name="optionName">Name of option</param>
            <param name="fallback">Value to be returned if registry key does not exist or has the wrong data type.</param>
            <returns>Value from registry, or fallback value if registry value does not exist.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Settings.GeneralSettings.GetValue(System.String,System.String,System.Int32)">
            <summary>
            Returns an integer value.
            This does a registry read each time (i.e. value is not cached).
            </summary>
            <param name="sectionName">Section name, e.g. "Timing".</param>
            <param name="optionName">Name of option</param>
            <param name="fallback">Value to be returned if registry key does not exist or has the wrong data type.</param>
            <returns>Value from registry, or fallback value if registry value does not exist.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Settings.GeneralSettings.GetString(System.String,System.String)">
            <summary>
            Checks if named setting is set. This does a registry read each time (i.e. value is not cached).
            </summary>
            <param name="optionName">Name of option</param>
            <param name="fallback">Value to be returned if registry key does not exist or has the wrong data type.</param>
            <returns>True if option is set (indicated by a DWORD value of 1 or higher).</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Settings.GeneralSettings.GetString(System.String,System.String,System.String)">
            <summary>
            Checks if named setting is set. This does a registry read each time (i.e. value is not cached).
            </summary>
            <param name="sectionName">Section name, e.g. "Timing".</param>
            <param name="optionName">Name of option</param>
            <param name="fallback">Value to be returned if registry key does not exist or has the wrong data type.</param>
            <returns>True if option is set (indicated by a DWORD value of 1 or higher).</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.UBAHandler">
            <summary>
            Multiple file downloader for special MCi UBA files.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.UBAHandler.AppFilename">
            <summary>
            Target filenames
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.UBAHandler._data">
            <summary>
            Data array.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.UBAHandler.#ctor(System.Byte[])">
            <summary>
            Constructor.
            </summary>
            <param name="data">File data from UBA file.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.UBAHandler.LoadUBAFile(System.String)">
            <summary>
            Attempts to load a file and returns a <seealso cref="T:ControlTechniques.CommsServer.UBAHandler"/> if it looks like a UBA file.
            </summary>
            <param name="file">Filename</param>
            <returns>UBAHandler instance if file appears to be a UBA, otherwise null.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.UBAHandler.LoadUBAData(System.Byte[])">
            <summary>
            Checks to see if the data given looks like a UBA file and if so returns a <seealso cref="T:ControlTechniques.CommsServer.UBAHandler"/>.
            </summary>
            <param name="data">File data array</param>
            <returns>UBAHandler instance if data appears to be a UBA, otherwise null. A reference to the data will be kept in the object returned.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.UBAHandler.Write(ControlTechniques.CommsServer.MessageQueue,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest,ControlTechniques.CommsServer.FileWriteOptions,ControlTechniques.CommsServer.T_FILE_STATUS@,System.TimeSpan@)">
            <summary>
            Writes an array of bytes to a target file.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.UBAHandler.FileTransferProgress(ControlTechniques.CommsServer.ECMPUserRequest,System.Int32,System.Int32,System.TimeSpan)">
            <summary>
            Progress notification - pass on overall times.
            </summary>
            <param name="request"></param>
            <param name="fileSize"></param>
            <param name="bytesTransferred"></param>
            <param name="elapsedTime"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.UBAHandler.Command">
            <summary>
            The UBA command.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.UBAHandler.CrcLen">
            <summary>
            Length of CRC data block.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.UBAHandler.AppLen">
            <summary>
            Length of application data block.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.UBAHandler.HeaderData">
            <summary>
            Header data
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.UBAHandler.CrcData">
            <summary>
            CRC data
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.UBAHandler.AppData">
            <summary>
            App data
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.Utils.NetworkInterfaceData">
            <summary>
            Helper class which gives useful info about a PC network adapter and its IPv4 settings.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.#ctor(System.Net.NetworkInformation.NetworkInterface)">
            <summary>
            Constructor.
            </summary>
            <param name="iface">Network interface.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.ToString">
            <summary>
            Gets the name. Same as <see cref="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.Name"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IsOnSameSubnet(System.Net.IPAddress)">
            <summary>
            Determines if a given address is on the same subnet as this PC adapter.
            See also <see cref="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IsValidForSubnet(System.Net.IPAddress)"/> which checks if address is on subnet and not the network/broadcast address.
            </summary>
            <param name="address">Address to check.</param>
            <returns>True if on same subnet.</returns>
            /// <seealso cref="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IsValidForSubnet(System.Net.IPAddress)">Use this to see if the address is on the same subnet and doesn't clash with this PC, broadcast or gateway address.</seealso>
        </member>
        <member name="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IsOnSameSubnet(System.Net.IPAddress,System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Determines if a given address is on the same subnet as another address.        
            </summary>
            <param name="address">Address to check.</param>
            <param name="netmask">Netmask associated with first address.</param>
            <param name="address2">Address to check is on same subnet.</param>
            <returns>True if on same subnet.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IsValidForSubnet(System.Net.IPAddress)">
            <summary>
            Determines if a given address is valid as a unicast address on the same subnet as this PC adapter and does not clash with
            the PC's address, broadcast address or gateway address.
            </summary>
            <param name="address">Address to check.</param>
            <returns>True if on same subnet and not the network or broadcast address or is the same as the PC's IP address.</returns>
            <seealso cref="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IsOnSameSubnet(System.Net.IPAddress)">Use this to see if the address is on the same subnet ignoring any other checks this method does.</seealso>
        </member>
        <member name="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.GetNetworkAddress(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Returns the network address for a given IPv4 address and netmask.
            </summary>
            <param name="address">IPv4 address</param>
            <param name="netmask">Netmask</param>
            <returns>Network address.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.GetNetmaskBits(System.Net.IPAddress)">
            <summary>
            Gets the netmask bits from a given netmask.
            </summary>
            <param name="netmask">Netmask.</param>
            <returns>Netmask bits (e.g. 255.255.0.0 will return 16).</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IsLegalSubnetMask(System.Net.IPAddress)">
            <summary>
            Checks if a netmask address is legal.
            </summary>
            <param name="mask">Mask.</param>
            <returns>True if ok, false if null or illegal.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.Interface">
            <summary>
            The network interface.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.Name">
            <summary>
            Gets the name (same as Interface.Name).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IpAddress">
            <summary>
            Gets the first IPv4 address the PC interface is assigned to.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.Netmask">
            <summary>
            Gets the netmask (associated with first IPv4 address).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.NetmaskBits">
            <summary>
            Gets the netmask number of bits (associated with first IPv4 address).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.Gateway">
            <summary>
            Gets the gateway (first IPv4 one).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.DhcpEnabled">
            <summary>
            Gets whether Dhcp is enabled or not.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.UsingLinkLocalAddress">
            <summary>
            Gets whether the interface is using a link local address (169.254.x.x)
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.NetworkAddress">
            <summary>
            Gets the network address (first address).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.LowestUsableNetworkAddress">
            <summary>
            Gets the lowest usable address (typically NetworkAddress + 1)
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.HighestUsableNetworkAddress">
            <summary>
            Gets the highest usable address (typically BroadcastAddress - 1)
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.NetworkBroadcastAddress">
            <summary>
            Gets the broadcast address.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.PhysicalAddress">
            <summary>
            NIC Physical (MAC) address.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.IpAddressWithMaskBits">
            <summary>
            Gets the IP address in format of a.b.c.d/mask.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Utils.NetworkInterfaceData.NetworkAddressWithMaskBits">
            <summary>
            Gets the network address in format of a.b.c.d/mask.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.NodeConfiguration">
            <summary>
            Allows configuration of Ethernet nodes using Discovery Protocol
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.NodeConfiguration.ConfigureNode(System.Collections.Generic.IEnumerable{System.Net.NetworkInformation.NetworkInterface},System.Net.NetworkInformation.PhysicalAddress,System.Boolean,System.Net.IPAddress,System.Net.IPAddress,System.Net.IPAddress,System.Int32,System.Int32)">
            <summary>
            Configures Ethernet Node using Discovery Protocol.
            The node must be accessible via UDP.
            </summary>
            <param name="interfaces">list of <see cref="T:System.Net.NetworkInformation.NetworkInterface"/> to use to configure the specified node. Specify null to issue request out on all appropriate interfaces.</param>
            <param name="nodeMACAddress"><see cref="T:System.Net.NetworkInformation.PhysicalAddress"/> of the node to configure</param>
            <param name="enableDHCP">Whether to enable DHCP on the node or not</param>
            <param name="ipAddress"><see cref="T:System.Net.IPAddress"/> to configure node with.</param>
            <param name="netmask">Netmask to configure node with.</param>
            <param name="gateway">Gateway to configure node with.</param>
            <param name="groupID">Group ID</param>
            <param name="nodeID">Node ID</param>
            <exception cref="T:System.ArgumentNullException">If any of <paramref name="nodeMACAddress"/>, <paramref name="ipAddress"/>, <paramref name="netmask"/> 
            or <paramref name="gateway"/> are null
            </exception>
            <exception cref="T:ControlTechniques.CommsServer.NoNetworkException">
            If none of the <paramref name="interfaces"/> specified are operational.
            </exception>
            <exception cref="T:ControlTechniques.CommsServer.NodeConfigurationException">
            If method fails to configure node specified with <paramref name="nodeMACAddress"/>.
            </exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.NodeConfiguration.ConfigureNode(System.Collections.Generic.IEnumerable{System.Net.NetworkInformation.NetworkInterface},System.Net.NetworkInformation.PhysicalAddress,System.String,System.String,System.Boolean,System.Net.IPAddress,System.Net.IPAddress,System.Net.IPAddress,System.Int32,System.Int32)">
            <summary>
            Configures Ethernet Node using Discovery Protocol.
            The node must be accessible via UDP.
            </summary>
            <remarks>
            If this method returns without exception then a node has responded to the reconfiguration.
            
            Note that it may take the node a few seconds to recofigure itself (especially if DHCP is enabled).
            </remarks>
            <param name="interfaces">list of <see cref="T:System.Net.NetworkInformation.NetworkInterface"/> to use to configure the specified node. Specify null to issue request out on all appropriate interfaces.</param>
            <param name="nodeMACAddress"><see cref="T:System.Net.NetworkInformation.PhysicalAddress"/> of the node to configure</param>
            <param name="username">Username. May be required by some node types (typically legacy such as SM-Ethernet).</param>
            <param name="password">Password - only relevant if Username set.</param>
            <param name="enableDHCP">Whether to enable DHCP on the node or not</param>
            <param name="ipAddress"><see cref="T:System.Net.IPAddress"/> to configure node with.</param>
            <param name="netmask">Netmask to configure node with.</param>
            <param name="gateway">Gateway to configure node with.</param>
            <param name="groupID">Group ID (used by legacy devices, set to 0 if not relevant)</param>
            <param name="nodeID">Node ID (used by legacy devices, set to 0 if not relevant)</param>
            <exception cref="T:System.ArgumentNullException">If any of <paramref name="nodeMACAddress"/>, <paramref name="ipAddress"/>, <paramref name="netmask"/> 
            or <paramref name="gateway"/> are null
            </exception>
            <exception cref="T:ControlTechniques.CommsServer.NoNetworkException">If none of the <paramref name="interfaces"/> specified are operational.</exception>
            <exception cref="T:ControlTechniques.CommsServer.NodeConfigurationException">If method fails to configure node specified with <paramref name="nodeMACAddress"/>.
            </exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.NodeConfiguration.GetNodeConfiguration(System.Collections.Generic.IEnumerable{System.Net.NetworkInformation.NetworkInterface},System.Net.NetworkInformation.PhysicalAddress,System.Boolean@,System.Boolean@,System.Net.IPAddress@,System.Net.IPAddress@,System.Net.IPAddress@,System.Int32@,System.Int32@)">
            <summary>
            Get the IP configuration for a node.
            </summary>
            <param name="interfaces">Interfaces to find node on. If null is passed in then all active interfaces will be iterated through to find the node (which may take some time).</param>
            <param name="nodeMACAddress">MAC address of the node.</param>
            <param name="dhcpEnabled">Returns DHCP enabled flag.</param>
            <param name="dhcpAcquired">Returns DHCP aquired flag.</param>
            <param name="ipAddress">Returns the IP address of the node.</param>
            <param name="netmask">Returns the netmask of the node.</param>
            <param name="gateway">Returns the gateway address of the node.</param>
            <param name="groupID">Returns the group id (used on legacy devices)</param>
            <param name="nodeID">Returns the group id (used on legacy devices)</param>
        </member>
        <member name="T:ControlTechniques.CommsServer.NodeConfigurationException">
            <summary>
            Exception thrown as a result of failure to configure ethernet node
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.NoNetworkException">
            <summary>
            Exception thrown if there is no valid network connection
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ParameterAddress">
            <summary>
            Represents the address of a parameter
            </summary>
            Why does this exist when it is so similar to ParameterID????
        </member>
        <member name="F:ControlTechniques.CommsServer.ParameterAddress.MaxBlockCount">
            <summary>
            Maximum amount of block parameters allowed.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ParameterAddress.MaxNullDataCount">
            <summary>
            Maximum amount of null data allowed.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterAddress.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a ParameterAddress for a slot, menu &amp; parameter;
            </summary>
            <param name="slot">Slot number (typically 0 means thst host drive, 1 is slot 1, etc.).</param>
            <param name="menu">Menu number</param>
            <param name="parameter">parameter number</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterAddress.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a ParameterAddress for a menu &amp; parameter;
            </summary>
            <param name="menu">menu number</param>
            <param name="parameter">parameter number</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterAddress.ParameterBlock(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a parameter address representing a contiguous block of parameters.
            </summary>
            <param name="menu">Starting menu number.</param>
            <param name="parameter">Starting parameter.</param>
            <param name="count">Number of parameters.</param>        
            <returns>ParameterAddress.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterAddress.ParameterBlockElement">
            <summary>
            Create a parameter address representing a block element.
            </summary>
            <remarks>
            Consumes no space in the process image but when used in conjunction with the Parameter Block mapping it can provide description attributes to each parameter within a block.
            </remarks>
            <returns>ParameterAddress.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterAddress.Null(System.Int32)">
            <summary>
            Create a NULL address.
            </summary>
            <param name="nullCount">Number of bytes to skip. Should be specified in multiples of 4 (UDINT).</param>
            <returns>ParameterAddress</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterAddress.CANOpenDictionaryObject(System.Int32,System.Int32)">
            <summary>
            Create an address for a CAN object dictionary reference
            </summary>
            <param name="index"></param>
            <param name="subindex"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterAddress.#ctor(System.Byte[],System.Int32@)">
            <summary>
            Constructs a <see cref="T:ControlTechniques.CommsServer.ParameterAddress"/> from the specified data
            </summary>
            <param name="data">data to construct <see cref="T:ControlTechniques.CommsServer.ParameterAddress"/> from.</param>
            <param name="from">index to start reading data from</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterAddress.ToBytes">
            <summary>
            Converts the Parameter Address to a sequence of bytes ready for sending in an eCMP request
            </summary>
            <returns>
            byte array
            </returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.AddressingScheme">
            <summary>
            Parameter Addressing Scheme
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.Menu">
            <summary>
            Menu number
            </summary>
            <remarks>
            null if not valid for this scheme
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.Parameter">
            <summary>
            Parameter Number
            </summary>
            <remarks>
            null if not valid for this scheme
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.Slot">
            <summary>
            Slot Number
            </summary>
            <remarks>
            null if not valid for this scheme
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.BlockCount">
            <summary>
            Number of parameters in block.
            </summary>
            <remarks>
            Only used with PARAMETER_BLOCK addressing scheme. See <seealso cref="M:ControlTechniques.CommsServer.ParameterAddress.ParameterBlock(System.Int32,System.Int32,System.Int32)"/> static method.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.NullDataCount">
            <summary>
            Amount of null data for the <see cref="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.NULL"/> scheme.
            Typically this will be specified in multiples of 4.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.VariableName">
            <summary>
            Variable Name
            </summary>
            <remarks>
            null if not valid for this scheme
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.Index">
            <summary>
            CANOpen Index number
            </summary>
            <remarks>
            null if not valid for this scheme
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterAddress.SubIndex">
            <summary>
            CANOpen SubIndex Number
            </summary>
            <remarks>
            null if not valid for this scheme
            </remarks>
        </member>
        <member name="T:ControlTechniques.CommsServer.ProgramControl">
            <summary>
            Enum used with <see cref="T:ControlTechniques.CommsServer.ECMPProgramControlRequest"/>
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ProgramControlResponse">
            <summary>
            Enum used with <see cref="T:ControlTechniques.CommsServer.ECMPProgramControlRequest"/>
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ProgramStatus">
            <summary>
            The status of a programming running
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.RuntimeStatus">
            <summary>
            
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.RuntimeStatus.Parse(System.Byte[])">
            <summary>
            Creates a <see cref="T:ControlTechniques.CommsServer.RuntimeStatus"/> object from raw bytes
            </summary>
            <param name="rawData"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="P:ControlTechniques.CommsServer.RuntimeStatus.RuntimeErrorId">
            <summary>
            Error ID causing the trip
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.RuntimeStatus.TaskErrorId">
            <summary>
            Task ID causing the trip
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.RuntimeStatus.ProgramStatus">
            <summary>
            Current program status
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SimpleSemaphore._syncObject">
            <summary>
            This object is used to synchronise access across threads
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.SmlProcessingResult">
            <summary>
            SML data processing result. - Returned by <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.ProcessResponse(System.Byte[],System.Collections.Generic.List{ControlTechniques.CommsServer.SmlSectionResponse}@)"/>.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlProcessingResult.Ok">
            <summary>Data was ok.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlProcessingResult.FailedUnrecognisedFormat">
            <summary>Data was not recognised as being valid SML.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlProcessingResult.FailedUnsupportedVersion">
            <summary>SML version is not supported.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlProcessingResult.FailedCrc">
            <summary>CRC of the file is wrong.</summary>        
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlProcessingResult.SectionCountMismatch">
            <summary>Number of sections in response doesn't match the number of sections in the request. Response data may not be valid.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlProcessingResult.InvalidSectionResponse">
            <summary>Section response data could not be understood.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlProcessingResult.FailedNotRegistered">
            <summary>Failed due to not being registered. This can happen if you try to process response data without initially calling Go().</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlProcessingResult.Timeout">
            <summary>No response is available.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.SmlCommsUser">
            <summary>
            Comms user that generates and processes Sequential Message List (SML) files.
            </summary>
            <remarks>
            Thread Safety: This class is not thread-safe.
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser.SmlVersion">
            <summary>
            The version number of SML file that will be generated by this class.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser.SmlHeaderId">
            <summary>
            SML header identifier including version number.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser.SmlHeaderIdVersionMask">
            <summary>
            The mask for the version number part in the header file.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser.MaximumSectionCount">
            <summary>
            Maximum number of sections permissable.
            </summary>
            \internal This is a artificial limit - file format actually allows 65535.
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser.MaximumRequestsPerSection">
            <summary>
            The maximum number of requests that can be added to a section.
            </summary>
            \internal This is a artificial limit - file format actually allows 65535.
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser.SectionCountOffset">
            <summary>
            Bytes from start of file to section count.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser.PadToBoundary">
            <summary>
            Boundary to pad data to. This is not part of the SML spec but it is a requirement for MCS comms and
            since it will have little impact in other use-cases we'll do it all the time. So this is an implementation
            specific behaviour.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser.OptionSmlIgnoreCrcMismatch">
            <summary>
            Option name for disabling CRC mismatch with response file.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser._smlStream">
            <summary>
            The stream that gets written to on <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.Stop"/> after calling <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.Go(System.IO.Stream)"/>.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser._sections">
            <summary>
            The sections.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser._currentSmlSection">
            <summary>
            The current section.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser._ecmpEngine">
            <summary>
            ECMP Engine
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlCommsUser._commsAddress">
            <summary>
            Comms address.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Go">
            <summary>
            Start SML generation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Go(System.IO.Stream)">
            <summary>
            Start SML generation for outputting to a given stream.
            </summary>
            <param name="s">Stream to output to when <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.Stop"/> is called.</param>
            <returns>Status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Go(ControlTechniques.CommsServer.Protocol)">
            <summary>
            Start SML data generation that will get sent to a device.
            </summary>
            <param name="protocol">Protocol needed to get access to the device.</param>
            <returns>Status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Stop">
            <summary>
            Finishes generation of the SML file. If <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.Go(System.IO.Stream)"/> was called, the stream will be written to with the complete
            SML file data.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.WriteSml(System.IO.Stream,System.UInt32@)">
            <summary>
            Writes the SML file to the stream.
            </summary>
            <param name="outputStream">Stream to write to.</param>
            <param name="crc">Returns the CRC of the SML payload. Undefined if status returned is not <see cref="F:ControlTechniques.CommsServer.T_STATUS.OK"/>.</param>
            <returns>Status. Will return <see cref="F:ControlTechniques.CommsServer.T_STATUS.FAILED"/> if stream is not writeable.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.NewSection">
            <summary>
            Create a new section. After calling this method, all subsequent ECMP requests will be added to the new section.
            </summary>
            <returns>Status. A status of FAILED is returned if the maximum number of sections has been reached.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.ProcessResponse(System.Byte[],System.Collections.Generic.List{ControlTechniques.CommsServer.SmlSectionResponse}@)">
            <summary>
            Parse SML response data. This must be a valid SML data stream containing only ECMP responses.
            </summary>
            <remarks>
            This method will refer to cached request data so that the reponses include the original request, therefore for this
            to work you must first create the SML request using Write(), CyclicLink(), NewSection(), etc. then send the SML file
            to the target device, then use the same instance of this object to process the response. In between sending the request
            and getting the response no other request methods should be called.
            
            You can call this method without having used the instance to create the request - in this case the responses will 
            not have any reference to the request and it is left to the client to interpret the responses correctly.
            
            If in the former case (where this instance is used to create the request) but the number of sections in the response from
            the target does not match the request, a warning result of <see cref="F:ControlTechniques.CommsServer.SmlProcessingResult.SectionCountMismatch"/> will be returned
            however processing the responses will attempt to continue but there will be a possibility that the responses received won't correctly
            tie in with the requests, therefore the client should be cautious in using the results.
            
            </remarks>
            <param name="responseBytes">Full response data obtained from target device.</param>
            <param name="responses">Responses returned.</param>
            <returns>Indication as to whether processing was ok.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Transmit(ControlTechniques.CommsServer.CommsAddress,System.Int32)">
            <summary>
            This method is not yet implemented.
            
            Transmit the SML file to the target device and (optionally) start a thread monitoring for a response file and process it.
            If a response is requested the ResponseAvailable event will be raised.
            </summary>
            <remarks>This method may only be used after a call to <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.Go(ControlTechniques.CommsServer.Protocol)"/>.</remarks>
            <param name="address">Address of device to send file to.</param>
            <param name="responseTimeout">Time to wait for a response file from the target. Specify 0 to not wait for a response.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Info(ControlTechniques.CommsServer.ECMPInfoRequest)">
            <summary>
            Get Info data from the target.
            
            The Response event will return an object of type ECMPInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Interrogate(ControlTechniques.CommsServer.ECMPInterrogateRequest)">
            <summary>
            Interrogate the target to determine if commands are supported or not.
            </summary>
            <param name="request">The request</param>
            <returns>A status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Read(ControlTechniques.CommsServer.ECMPReadRequest)">
            <summary>
            Read parameter values from the target.
            
            The Response event will return an object of type ECMPReadResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.ReadWithType(ControlTechniques.CommsServer.ECMPReadWithTypeRequest)">
            <summary>
            Read parameter values with type information from the target.
            
            The Response event will return an object of type ECMPReadWithTypeResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Write(ControlTechniques.CommsServer.ECMPWriteRequest)">
            <summary>
            Write parameter values to the target.
            
            The Response event will return an object of type ECMPWriteResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.ObjectInfo(ControlTechniques.CommsServer.ECMPObjectInfoRequest)">
            <summary>
            Get Object Info from the target.
            
            The Response event will return an object of type ECMPObjectInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.GetNextObjects(ControlTechniques.CommsServer.ECMPGetNextObjectsRequest)">
            <summary>
            Get Next Objects from the target.
            
            The Response will include an object of type ECMPGetNextObjectsResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.FileDelete(ControlTechniques.CommsServer.FileDeleteMessageRequest)">
            <summary>
            Delete a file on the target.
            
            The Response event will return an object of type FileDeleteMessageResponse. 
            </summary>
            <remarks>
            A file delete operation is performed by first opening the file for writing then deleting it.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.FolderCreate(ControlTechniques.CommsServer.FolderCreateMessageRequest)">
            <summary>
            Create a folder on the target.
            
            The Response event will return an object of type FolderCreateMessageResponse. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.GetSyncInfo(ControlTechniques.CommsServer.ECMPSyncInfoRequest)">
            <summary>
            Get Sync Info
            </summary>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.CyclicLink(ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)">
            <summary>
            Cyclic Link Command. This will always use the new CyclicLink command as defined in ECMP specification V1.0.
            </summary>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.GetDiagnostics(ControlTechniques.CommsServer.ECMPDiagnosticRequest)">
            <summary>
            Get Diagnostics information
            </summary>
            <param name="request">Request to send.</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.GetProgramStatus(ControlTechniques.CommsServer.ECMPProgramStatusRequest)">
            <summary>
            Get the status of the program running
            </summary>
            <param name="request">Request to send.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.SetProgramControl(ControlTechniques.CommsServer.ECMPProgramControlRequest)">
            <summary>
            Sets the state of the user program
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Request(ControlTechniques.CommsServer.ECMPUserRequest)">
            <summary>
            Queue a request.
            </summary>
            <param name="request">Request.</param>
            <returns>Status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.Request(System.Collections.Generic.IEnumerable{ControlTechniques.CommsServer.ECMPUserRequest})">
            <summary>
            Queue requests.
            </summary>
            <param name="requests">List of requests.</param>
            <returns>Status code - queuing will be halted at the first failure.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.LoadRequestFile(System.String)">
            <summary>
            Load a SML request file.
            </summary>
            <remarks>Any existing SML requests queued in the user object will be cleared.</remarks>
            <param name="filename">SML request filename.</param>
            <returns><c>true</c> if file read ok.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.ReadRequestStream(System.IO.Stream)">
            <summary>
            Read a SML request stream.
            </summary>
            <remarks>Any existing SML requests queued in the user object will be cleared.</remarks>
            <param name="s"></param>
            <returns><c>true</c> if stream read ok.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ControlTechniques.CommsServer.SmlCommsUser.InternalGo" -->
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.ValidateSmlHeader(System.Byte[],System.UInt32@)">
            <summary>
            Check SML data header and CRC.
            </summary>
            <param name="data">Data</param>
            <param name="crc">CRC of the data</param>
            <returns>Response.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlCommsUser.QueueRequest(ControlTechniques.CommsServer.ECMPUserRequest)">
            <summary>
            Add a ECMP user request to the current section.
            </summary>
            <param name="request">Request to add.</param>
            <returns>Will return OK unless there's no valid section or section is full in which case FAILED is returned.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlCommsUser.DataCrc">
            <summary>
            CRC of SML data payload - this is only valid immediately after a call to <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.WriteSml(System.IO.Stream,System.UInt32@)"/>, <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.Stop"/> (when <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.Go(System.IO.Stream)"/> was used),
            or <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.LoadRequestFile(System.String)"/>/<see cref="M:ControlTechniques.CommsServer.SmlCommsUser.ReadRequestStream(System.IO.Stream)"/>.
            It is not necessary to use this property with <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.WriteSml(System.IO.Stream,System.UInt32@)"/> as that returns the CRC as an output argument anyway.
            Note this is not a CRC of the entire SML data as it excludes the file header (which comprises of a file identifier and CRC).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlCommsUser.MaxTransmitBufferSizeBytes">
            <summary>
            Max buffer tx buffer size. Will be used if sending SML data to a device.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlCommsUser.TheProtocol">
            <summary>
            Protocol. Used when sending SML data to a device.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlCommsUser.CommsAddress">
            <summary>
            The comms address. This is defaulted to intercept address (CommsAddress.InterceptAddress) meaning the request is to be
            handled by the device directly.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlCommsUser.Sections">
            <summary>
            SML sections. Read-only.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlCommsUser.IsActive">
            <summary>
            Returns <c>true</c> if <see cref="M:ControlTechniques.CommsServer.SmlCommsUser.Go"/> has been called.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.SmlResponse">
            <summary>
            A SML response. This is just a list of <see cref="T:ControlTechniques.CommsServer.SmlSectionResponse"/> items.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlResponse.Sections">
            <summary>
            Responses for each section.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.SmlSection">
            <summary>
            A SML file section. Container for a number of commands/responses.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlSection.RequestList">
            <summary>
            The requests in this section.
            </summary>        
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlSection.AddRequest(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPUserRequest)">
            <summary>
            Add a ECMP user request.
            </summary>
            <param name="address">Address message is targeted at.</param>
            <param name="request">Request to add.</param>
            <returns>Will return OK unless the section is full in which case FAILED is returned.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlSection.ToBytes(ControlTechniques.CommsServer.ECMPTxRxLayer)">
            <summary>
            Converts the section into a byte array.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlSection.FromBytes(System.Byte[],System.Int32@)">
            <summary>
            Decode a SML request section.
            </summary>
            <param name="b">Data</param>
            <param name="from">Current offset into the data.</param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlSection.Requests">
            <summary>
            Enumerable list of requests in this section.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.SmlSectionResponse">
            <summary>
            SML section response.
            </summary>
            <remarks>
            This class holds response data for a SML section. A section is comprised of a number of ECMP message responses.
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.SmlSectionResponse.Requests">
            <summary>
            The requests in this section.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlSectionResponse.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SmlSectionResponse.FromBytes(ControlTechniques.CommsServer.ECMPTxRxLayer,System.Byte[],System.UInt32,ControlTechniques.CommsServer.SmlSection)">
            <summary>
            Create a section response from a SML response data stream.
            </summary>
            <param name="ecmpEngine">ECMPTxRxLayer engine which will be used to decode ECMP message headers.</param>
            <param name="data">Raw data which includes the section response data.</param>
            <param name="offset">Offset to start of section data.</param>
            <param name="requestSection">Original request. May be set to null if request is not available.</param>
            <returns>Section response, or null if failed - most likely due to malformed data.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlSectionResponse.Responses">
            <summary>
            The list of responses.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.SmlSectionResponse.FullyProcessed">
            <summary>
            Indicates if all requests have responses. This will only be valid if request data was available.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.SynchronousCommunications">
            <summary>
            Provides synchronous comms.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.SetTimeouts(ControlTechniques.CommsServer.CommunicationsTimeouts)">
            <summary>
            Set the timeouts for the process.
            </summary>
            <param name="TheTimeouts"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.Timeouts">
            <summary>
            Returns the communications timeout.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.Compound(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCompoundRequest,ControlTechniques.CommsServer.ECMPCompoundResponse@)">
            <summary>
            Send a compound request to a device.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.Identify(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPIdentifyRequest,ControlTechniques.CommsServer.ECMPIdentifyResponse@)">
            <summary>
            Get Identify data from the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.Info(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest,ControlTechniques.CommsServer.ECMPInfoResponse@)">
            <summary>
            Get Info data from the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.Interrogate(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInterrogateRequest,ControlTechniques.CommsServer.ECMPInterrogateResponse@)">
            <summary>
            Interrogate the target to determine if commands are supported or not.
            </summary>
            <param name="TheProtocol">Connection protocol and settings</param>
            <param name="Address">Address of target</param>
            <param name="Request">The request</param>
            <param name="Response">The response from the target</param>
            <returns>Response status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.Reset(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPResetRequest,ControlTechniques.CommsServer.ECMPResetResponse@)">
            <summary>
            Reset the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.TunnelFrame(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.TunnelFrameRequest,ControlTechniques.CommsServer.TunnelFrameResponse@)">
            <summary>
            Send a TunnelFrame message to the target.
            
            Note: The commsserver will automatically break the data into chunks
            for transmission, e.g. you can send 10K bytes and the comms layer
            will send a series of messages to get the data into the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.Read(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest,ControlTechniques.CommsServer.ECMPReadResponse@)">
            <summary>
            Read parameter values from the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.ReadWithType(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest,ControlTechniques.CommsServer.ECMPReadWithTypeResponse@)">
            <summary>
            Read parameter values with type information from the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.Write(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest,ControlTechniques.CommsServer.ECMPWriteResponse@)">
            <summary>
            Write parameter values to the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.ObjectInfo(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPObjectInfoRequest,ControlTechniques.CommsServer.ECMPObjectInfoResponse@)">
            <summary>
            Get Object Info from the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.GetNextObjects(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPGetNextObjectsRequest,ControlTechniques.CommsServer.ECMPGetNextObjectsResponse@)">
            <summary>
            Get Next Objects from the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.FileDelete(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileDeleteMessageRequest,ControlTechniques.CommsServer.FileDeleteMessageResponse@)">
            <summary>
            Delete a file on the target.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.FileReadBytes(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadBytesMessageRequest,ControlTechniques.CommsServer.FileReadBytesMessageResponse@)">
            <summary>
            Read the contents of a target file into an array of bytes.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.FileReadDisk(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadDiskMessageRequest,ControlTechniques.CommsServer.FileReadDiskMessageResponse@)">
            <summary>
            Read the contents of a target file into a file on disk.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.FileWriteBytes(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest,ControlTechniques.CommsServer.FileWriteBytesMessageResponse@)">
            <summary>
            Write the contents of a target file from an array of bytes.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.FileWriteDisk(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest,ControlTechniques.CommsServer.FileWriteDiskMessageResponse@)">
            <summary>
            Write the contents of a target file from a file on disk.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.SynchronousCommunications.FileList(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileListRequest,ControlTechniques.CommsServer.FileListResponse@)">
            <summary>
            Obtain a list of files in a given directory.
            
            The Response will be an object of type FileListResponse. 
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.SynchronousCommunications.MaxTransmitBufferSizeBytes">
            <summary>
            Return the maximum number of bytes a client can place into a tunneled frame (for example).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest" -->
        <member name="M:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest"/> class.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.ToBytes">
            <summary>
            Return the message as a byte array suitable for transmission.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.CreateTunnelFrameRequest(System.Byte[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a new tunnel frame request.
            </summary>
            <param name="tunnelledData">The data to include in the tunnelled message.</param>
            <param name="startOfFrame">if set to <c>true</c> this is the first frame of the request].</param>
            <param name="endOfFrame">if set to <c>true</c> there will be no further tunnelled requests after this one.</param>
            <param name="checkOutput">if set to <c>true</c> the check output flag will be set on the request.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.EndOfFrame">
            <summary>
            The control flag that indicates that there are will be more no more tunnelled frames to follow this one
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.StartOfFrame">
            <summary>
            This flag indicates that this request is carrying the first of a potentially multi-frame message
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.CheckOutput">
            <summary>
            The control flag that indicates that this is the last tunnelled frame in a sequence (possibly the only frame in the sequence) and the target
            should process the response to the request if one is warranted.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.Error">
            <summary>
            The control flag that indicates that an error occurred when processing the request - generally this is no proxy but it could be anything.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.EmbeddedData">
            <summary>
            The actual data that is to be tunnelled to the target
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.OverridingTimeout">
            <summary>
            An overriding timeout for this particular message.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageRequest.RequestLength">
            <summary>
            Returns the number of bytes of the request (excluding data).
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse">
            <summary>
            A Tunnel Frame response.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse"/> class.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse.CreateFrom(System.Byte[],System.Int32)">
            <summary>
            Create a <see cref="T:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse"/> object from the raw PDU bytes in the <paramref name="frame"/> parameter.  The data should be parsed
            starting from (and including) the byte at index <paramref name="fromIndex"/>.
            </summary>
            <param name="frame">The PDU bytes containing the response bytes from which to create the response object</param>
            <param name="fromIndex">The index at which to start parsing the response data</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse.MoreData">
            <summary>
            There is more response data available to be retrieved so further requests should be sent to retrieve it
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse.StartOfFrame">
            <summary>
            Indicates that this is the first frame of the response
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse.EndOfFrame">
            <summary>
            Indicates that this is the last frame of the response
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse.Error">
            <summary>
            The control flag that indicates that an error occurred when processing the request - generally this is no proxy but it could be anything.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse.TargetResetting">
            <summary>
            This flag will be set by the target if it is about to reset. The comms server should be pause comms to the target for a few seconds.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTunnelFrameMessageResponse.EmbeddedData">
            <summary>
            The actual data that was returned from the target
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.CRC32">
             <summary>
             Provides an implementation of CRC32 (32-bit CRC) as used in Ethernet, PKZip etc.
            			This implementation is capable of providing a small footprint version, optimised
            				for ROM and RAM size rather than speed, or a slightly larger footprint version
            				optimised for speed.
            				To optimise for speed define "OPTIMISE_FOR_SPEED" in file "crc32cfg.hpp".
            
            				Optimised for speed:
            
            					Code usage on SH2A:					   88 bytes
            					Const usage on SH2A:				 1032 bytes
            					Stack usage on SH2A:				   12 bytes
            					Time to CRC 1024 bytes:				  360 us		(370ns per byte)
            					Time to CRC 32768 bytes:			12200 us		(370ns per byte)
            
            				Not optimised for speed:
            
            					Code usage on SH2A:					  156 bytes
            					Const usage on SH2A:				    8 bytes
            					Stack usage on SH2A:				    4 bytes
            					Time to CRC 1024 bytes:				 2250 us		(2.2us per byte)
            					Time to CRC 32768 bytes:			71800 us		(2.2us per byte)
            
            				Timing tests conducted on UT70A, SH2A running at 57.4MHz code running from
            				internal (single cycle) flash, CRCing data in internal flash, Stack in external RAM:
             </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.CRC32.Calculate(System.Byte[],System.Int32,System.Int32,ControlTechniques.CommsServer.CRC32.T_CRC_DIRECTION)">
            <summary>
            Calculate CRC of a data array.
            </summary>
            <param name="Data">Data.</param>
            <param name="Offset">Offset from start of array.</param>
            <param name="Length">Number of bytes in array over which to calculate the CRC.</param>
            <param name="Direction"></param>
            <returns>CRC value.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.CRC32.Calculate(System.Byte[],System.Int32,ControlTechniques.CommsServer.CRC32.T_CRC_DIRECTION)">
            <summary>
            Calculate CRC of a data array.
            </summary>
            <param name="Data">Data.</param>
            <param name="Length">Number of bytes in array over which to calculate the CRC.</param>
            <param name="Direction"></param>
            <returns>CRC value.</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.DataLoop">
            <summary>
            Implements the data loop for a port - periodically polls parameter values and indicates any change in value or status
            to interested clients.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.mLoopNodes">
            <summary>
            The loop nodes.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.mWorker">
            <summary>
            The worker thread that implements the transmission and reception.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.mSemaphore">
            <summary>
            A semaphore used to communicate with the loop worker thread.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.mResponse">
            <summary>
            The response received from the target.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.mResponseAvailable">
            <summary>
            Indicates if a response has been received from the comms layer.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.mResponseStatus">
            <summary>
            The status of the response.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.mASyncUser">
            <summary>
            The comms user for the data loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.ClearResponse">
            <summary>
            Clear the indication that a response from the target is awaiting processing.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.SetResponse(ControlTechniques.CommsServer.ECMPReadWithTypeResponse,ControlTechniques.CommsServer.T_RESPONSE_STATUS)">
            <summary>
            Store the response from the target.
            </summary>
            <param name="theResponse"></param>
            <param name="theResponseStatus"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.GetNode(ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Get a node for a specified address.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.GetResponse(ControlTechniques.CommsServer.ECMPReadWithTypeResponse@,ControlTechniques.CommsServer.T_RESPONSE_STATUS@,System.DateTime@)">
            <summary>
            Get the response from the target.
            </summary>
            <param name="theResponse"></param>
            <param name="theResponseStatus"></param>
            <param name="timeStamp">The time the response was received. If there's no response data (e.g. due to timeout) the timestamp will be the current time.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.InvalidateLoopParameters(ControlTechniques.CommsServer.CommsAddress,System.Collections.Generic.List{ControlTechniques.CommsServer.ParameterIDAndValueAndDPs})">
            <summary>
            Mark the specified parameters as unread so that they are refreshed via the loop.
            </summary>
            <param name="Parameters"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.AddParameter(ControlTechniques.CommsServer.DataLoopUser,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ParameterID,System.Object)">
            <summary>
            Add a parameter into the loop. If the same user already has the parameter in the loop, the add
            request will effectively be ignored.
            </summary>
            <remarks>
            There is currently a limitation that all parameters added to the dataloop for a given address must use the same parameter addressing scheme [BUG#5185].
            </remarks>
            <returns>True if parameter was added.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.RemoveUserForParameter(ControlTechniques.CommsServer.DataLoopUser,ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ParameterID)">
            <summary>
            Remove a parameter from the loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.RemoveUserForParametersWithTag(ControlTechniques.CommsServer.DataLoopUser,System.Object)">
            <summary>
            Remove parameters for a specific user from the loop that have a given tag.
            If other users are interested in the same parameters, the parameter will remain in the loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.RemoveUserForParameter(ControlTechniques.CommsServer.DataLoopUser)">
            <summary>
            Remove all parameters for a specific user from the loop. If other users are interested in the same 
            parameters, the parameter will remain in the loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.ClearLoop">
            <summary>
            Removes all parameters from the loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.#ctor(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.T_STATUS@)">
            <summary>
            Starts the loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.Stop">
            <summary>
            Stop the loop - the loop cannot be restarted after this call - a new object needs to be instantiated.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.mASyncUser_Response(ControlTechniques.CommsServer.ASynchronousCommsUser,System.Object,ControlTechniques.CommsServer.T_RESPONSE_STATUS)">
            <summary>
            Handle a response over comms.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.GetIndexes(System.Int32@,System.Int32@)">
            <summary>
            Get the index of the next node/ parameter to be read from a target.
            </summary>
            <param name="nodeIndex"></param>
            <param name="parameterIndex"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.GetECMPReadWithTypeRequest(ControlTechniques.CommsServer.CommsAddress@,ControlTechniques.CommsServer.ECMPReadWithTypeRequest@,System.Int32@,System.Int32@)">
            <summary>
            Traverses the nodes and parameters, constructing an ECMP Read Request.
            
            NodeIndex is the index of the next node to poll in mLoopNodes.
            
            ParameterIndex is the index of the next parameter to poll in the list of parameters for the selected node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.ProcessReceive(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest,ControlTechniques.CommsServer.ECMPReadWithTypeResponse)">
            <summary>
            Process received data, letting the client's know if data is bad/ good or if its value has changed.
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <param name="response"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.IndicateBadNode(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS)">
            <summary>
            Let interested client's know the data from the specified address is uncertain.
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.IndicateGoodNode(ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Indicate we can talk to the node.
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.mWorker_DoWork(System.Object,System.ComponentModel.DoWorkEventArgs)">
            <summary>
            Implement the data loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.KickWorker">
            <summary>
            Lets the loop worker know there's something to do.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DataLoop.LoopParameterList">
            <summary>
            A list of loop parameters where parameters are grouped into parameter addressing schemes, i.e. all STANDARD scheme parameters are together and
            all SLOT_SPECIFIC parameters are together.
            </summary>
            <remarks>
            This list class is not thread safe.
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.LoopParameterList._schemeIndices">
            <summary>
            For efficiency in adding/removing hold a list of indecies for different parameter addressing schemes. This will be the index into
            the _list list of the last inserted item of a particular scheme.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.LoopParameterList._list">
            <summary>
            Parameter list.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameterList.Add(ControlTechniques.CommsServer.DataLoop.LoopParameter)">
            <summary>
            Add a parameter to the list.
            </summary>
            <param name="item">Loop parameter</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameterList.Clear">
            <summary>
            Clear all parameters.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameterList.Contains(ControlTechniques.CommsServer.DataLoop.LoopParameter)">
            <summary>
            Checks if list contains item.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameterList.Remove(ControlTechniques.CommsServer.DataLoop.LoopParameter)">
            <summary>
            Remove a parameter from the list.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameterList.Get(ControlTechniques.CommsServer.ParameterID)">
            <summary>
            Gets a LoopParameter that matches the given ParameterID.
            </summary>
            <param name="parameterToGet">Parameter to get</param>
            <returns>LoopParameter or null if not found.</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.DataLoop.LoopNode">
            <summary>
            The data stored for each node in the loop. The node's address and the parameters are stored.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.LoopNode._nodeState">
            <summary>
            Keeps a record of the state of comms to the node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.#ctor(ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            Construct a loop node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.InvalidateParameter(ControlTechniques.CommsServer.ParameterID)">
            <summary>
            Invalidates a parameter so that its value is sent to loop subscribers on the next read even
            if the value has not changed.
            </summary>
            <param name="theParameter"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.AddParameter(ControlTechniques.CommsServer.DataLoopUser,ControlTechniques.CommsServer.ParameterID,System.Object)">
            <summary>
            Adds a parameter into the polling loop for the node.
            
            Returns false if the parameter was already in the loop, otherwise true.
            </summary>
            <param name="theUser"></param>
            <param name="theParameter"></param>
            <param name="tag">Optional user data.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.RemoveUserForParameter(ControlTechniques.CommsServer.DataLoopUser,ControlTechniques.CommsServer.ParameterID)">
            <summary>
            Removes a user's reference for a parameter from the polling loop for a node.
            
            If there are no remaining users for a parameter, the parameter is removed from the loop.
            </summary>
            <param name="theUser"></param>
            <param name="theParameter"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.RemoveUserForParametersWithTag(ControlTechniques.CommsServer.DataLoopUser,System.Object)">
            <summary>
            Remove the user for parameters with a matching tag of the user.
            </summary>
            <param name="theUser">User</param>
            <param name="tag">Tag. Should not be null.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.RemoveUserForAllParameters(ControlTechniques.CommsServer.DataLoopUser)">
            <summary>
            Removes a user's reference for ALL parameters in the polling loop for a node.
            
            If there are no remaining users for a parameter, the parameter is removed from the loop.
            </summary>
            <param name="theUser"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.IndicateGoodParameter(ControlTechniques.CommsServer.ParameterID,ControlTechniques.CommsServer.ParameterWithType,System.DateTime)">
            <summary>
            Indicates that a good parameter value has been returned and notifies interested clients.
            </summary>
            <param name="parID"></param>
            <param name="theParameter"></param>
            <param name="timeStamp">Timestamp of message.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.IndicateBadParameter(ControlTechniques.CommsServer.ParameterID,ControlTechniques.CommsServer.ParameterWithType,System.DateTime)">
            <summary>
            Indicates that a bad parameter value has been returned and notifies interested clients.
            </summary>
            <param name="parID"></param>
            <param name="theParameter"></param>
            <param name="timeStamp">Timestamp of message.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.IndicateGoodNode">
            <summary>
            Indicates we managed to talk to the node.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopNode.IndicateBadNode(ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS)">
            <summary>
            Indicates that a bad node is present, i.e. a node we can't talk to.
            This will update the status of all parameters for the node and inform the user.
            </summary>
            <param name="status">The status to mark the parameters for the node..</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.DataLoop.LoopNode.Parameters">
            <summary>
            The parameters being polled for the node.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DataLoop.LoopNode.Address">
            <summary>
            The comms address.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DataLoop.LoopNode.ShouldTalk">
            <summary>
            Indicates if we should attempt comms to the node.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DataLoop.LoopParameter">
            <summary>
            The data stored for each parameter in the loop.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.LoopParameter.Status">
            <summary>
            The status of the parameter.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoop.LoopParameter.Value">
            <summary>
            The parameter information.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameter.Equals(System.Object)">
            <summary>
            Implement the equals operation.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameter.AddUser(ControlTechniques.CommsServer.DataLoopUser,System.Object)">
            <summary>
            Adds the specified user to this parameter.
            </summary>
            <param name="user">The user.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameter.TagForUser(ControlTechniques.CommsServer.DataLoopUser)">
            <summary>
            Returns the tag for a specific user.
            </summary>
            <param name="User"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameter.RemoveUser(ControlTechniques.CommsServer.DataLoopUser)">
            <summary>
            Removes the user from the list of users for this parameter.
            </summary>
            <param name="user">The user.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameter.RequiresUpdate(ControlTechniques.CommsServer.DataLoopUser)">
            <summary>
            Check if the user requires an update on the parameter value, this is usually be true after the user has been added to the list of users that
            have an interest in this parameter.  This flag will remain true until cleared by a call to <see cref="M:ControlTechniques.CommsServer.DataLoop.LoopParameter.RequiresUpdate(ControlTechniques.CommsServer.DataLoopUser,System.Boolean)"/>
            </summary>
            <param name="user">The user.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoop.LoopParameter.RequiresUpdate(ControlTechniques.CommsServer.DataLoopUser,System.Boolean)">
            <summary>
            Check if the user requires an update on the parameter value, this is usually be true after the user has been added to the list of users that
            have an interest in this parameter.  The flag will then be set to the value provided in <paramref name="requiresUpdate"/>.
            </summary>
            <param name="user">The user.</param>
            <param name="requiresUpdate">The value to set the requires update flag to</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.DataLoop.LoopParameter.Users">
            <summary>
            The users interested in the parameter.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DataLoop.LoopParameter.OK">
            <summary>
            Indicates if the parameter status is OK.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DataLoop.LoopParameter.NumberOfUsers">
            <summary>
            Gets the number of users.
            </summary>
            <value>The number of users.</value>
        </member>
        <member name="T:ControlTechniques.CommsServer.ParameterUpdatedEventArgs">
            <summary>
            Class used with the <see cref="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated"/> event, giving details of a parameter update.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterUpdatedEventArgs.Ok">
            <summary>
            Indicates if value is good (i.e. parameter was successfully read from the device).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterUpdatedEventArgs.Parameter">
            <summary>
            Parameter and its value.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterUpdatedEventArgs.Status">
            <summary>
            Status of parameter access.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterUpdatedEventArgs.Address">
            <summary>
            Address of device parameter came from.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterUpdatedEventArgs.TimeStamp">
            <summary>
            Timestamp when response was received by the PC.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterUpdatedEventArgs.Tag">
            <summary>
            User tag.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DataLoopUser">
            <summary>
            A data loop user class. This class is used to continually monitor parameters and receive notifications (via an event) when a parameter value changes.
            </summary>
            <remarks>
            Use <see cref="M:ControlTechniques.CommsServer.DataLoopUser.AddParameter(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ParameterID)"/> (and variants) to add parameters to the data loop.
            Subscribe to the <see cref="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated"/> event to handle value updates.</remarks>    
            
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoopUser.mLoop">
            <summary>
            The loop object.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.DataLoopUser.mOperation">
            <summary>
            Used to cache the thread of the constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.#ctor">
            <summary>
            Constructor.
            </summary>
            <remarks>
            Note that the events raised by this class will be made on the same thread that this constructor is called from.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.Stop">
            <summary>
            Releases the data loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.Go(ControlTechniques.CommsServer.Protocol)">
            <summary>
            Starts a loop for the specified protocol. 
            </summary>
            <param name="TheProtocol"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.AddParameter(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,System.Object)">
            <summary>
            Add a parameter to the data loop.
            </summary>
            <param name="address">Comms address.</param>
            <param name="menu">Menu number</param>
            <param name="parameter">Slot number</param>
            <param name="tag">User data tag - this will be returned in the <see cref="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated"/> event arguments. May be <c>null</c> if not needed.</param>
            <returns><c>True</c> if parameter was added (or is already in the loop).</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.AddParameter(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ParameterID)">
            <summary>
            Add a parameter into the loop.
            </summary>
            <param name="Address">Comms address</param>
            <param name="Parameter">Parameter to add to loop.</param>
            <seealso cref="M:ControlTechniques.CommsServer.DataLoopUser.AddParameter(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ParameterID,System.Object)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.AddParameter(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ParameterID,System.Object)">
            <summary>
            Add a parameter into the loop.
            </summary>
            <param name="address">Comms address</param>
            <param name="parameter">Parameter to add to loop.</param>
            <param name="tag">Optional user data - this will be returned in the <see cref="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated"/> event arguments.</param>
            <seealso cref="M:ControlTechniques.CommsServer.DataLoopUser.AddParameter(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ParameterID)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.RemoveParameter(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ParameterID)">
            <summary>
            Remove a parameter from the loop.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.RemoveParametersWithTag(System.Object)">
            <summary>
            Remove all parameters that have the specified tag.
            </summary>
            <param name="tag">Tag, as passed in to one of the <c>AddParameter</c> methods.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.InternalLoopParameterUpdated(ControlTechniques.CommsServer.CommsAddress,System.Boolean,ControlTechniques.CommsServer.ParameterIDAndValueAndDPs,System.Object,System.DateTime,ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS)">
            <summary>
            This method is for internal use by the data loop - clients should not access the method.
            </summary>
            <param name="ParameterOK"></param>
            <param name="Parameter"></param>
            <param name="Tag"></param>
            <param name="timestamp"></param>
            <param name="status"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.DataLoopUser.Dispose">
            <summary>
            Dispose. Ensures comms is released.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.DataLoopUser.IsActive">
            <summary>
            Returns whether the user is active, i.e. <see cref="M:ControlTechniques.CommsServer.DataLoopUser.Go(ControlTechniques.CommsServer.Protocol)"/> has been called.
            </summary>
        </member>
        <member name="E:ControlTechniques.CommsServer.DataLoopUser.ParameterUpdated">
            <summary>
            Obsolete. This event fires when a parameter has been updated. This event has been superseded by the <see cref="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated"/> event.
            </summary>
            \deprecated Use <see cref="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated"/> event.
        </member>
        <member name="E:ControlTechniques.CommsServer.DataLoopUser.ParameterWithAddressUpdated">
            <summary>
            Obsolete. This event fires when a parameter has been updated. This event has been superseded by the <see cref="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated"/> event.
            </summary>
            \deprecated Use <see cref="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated"/> event.
        </member>
        <member name="E:ControlTechniques.CommsServer.DataLoopUser.ParameterValueUpdated">
            <summary>
            Event fired when a parameter value changes or the status changes.
            The event will be raised on the thread that was used when this class instance was constructed.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DataLoopUser.ParameterUpdatedHandler">
            <summary>
            Obsolete. Handler for parameter updates.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.DataLoopUser.ParameterWithAddressUpdatedHandler">
            <summary>
            Obsolete. Handler for parameter update with address.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_ADDRESSING_SCHEME">
            <summary>
            ECMP addressing schemes
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_RESPONSE_STATUS">
            <summary>
            The comms Q status.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_TO_TRANSMIT">
            <summary>The request could not be transmitted.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.RESPONSE_TIMED_OUT">
            <summary>Timeout - no response was received from the device.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_UNEXPECTED_RESPONSE">
            <summary>The response was not what was expected.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_FILE_NOT_OPENED">
            <summary>The file could not be opened.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_FILE_ERROR_RESPONSE">
            <summary>A file operation failed.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_TO_CLOSE_FILE">
            <summary>The file could not be closed.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_FILE_UNABLE_TO_READ_FROM_DISK">
            <summary>A local file on the PC could no be found or read.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_UNABLE_TO_WRITE_DISK_FILE">
            <summary>A local on the PC could not be written. Check permissions.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_TO_DELETE_FILE">
            <summary>The file could no be deleted.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_UNRECOGNISED_TRANSMIT_REQUEST">
            <summary>The request type is not supported.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_CANCELLED">
            <summary>The operation was cancelled.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_INVALID_REQUEST">
            <summary>The request was invalid, possibly due to the data in the request violating a rule./</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_STATUS">
            <summary>
            Operation statuses.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_STATUS.OK">
            <summary>OK</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_STATUS.FAILED">
            <summary>General failure</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_STATUS.FAILED_TO_REGISTER">
            <summary>Failed to register with server</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_STATUS.FAILED_NOT_REGISTERED">
            <summary>Failed as not registered with server.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_STATUS.FAILED_REQUEST_TOO_LONG">
            <summary>Failed as request to long.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_STATUS.FAILED_INVALID_REQUEST">
            <summary>The request was invalid, possibly due to the data in the request violating a rule.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_INFO_TYPE">
            <summary>
            The classes of info that can be requested.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.MIN_IN_MENU">
            <summary>The lowest numbered parameter in the menu (parameter number in request is ignored).</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.MAX_IN_MENU">
            <summary>The highest numbered parameter in the menu  (parameter number in request is ignored).</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.PARAM_FORMAT">
            <summary>The format data of the specified parameter</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.MIN_VALUE">
            <summary>The minimum value allowed value for the specified parameter</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.MAX_VALUE">
            <summary>The maximum value allowed value for the specified parameter</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.UNITS">
            <summary>The units ID for the specified parameter</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.DATA_TYPE">
            <summary>The data type of the specified parameter</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.FIRST_MENU">
            <summary>The lowest numbered menu in the device (menu and parameter info in request are ignored)</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.LAST_MENU">
            <summary>The highest numbered menu in the device (menu and parameter info in request are ignored)</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.MENU_CUSTOMISATION_INFO">
            <summary>Version information for the menu if it has been customised.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_INFO_TYPE.DATABASE_VERSION_INFO">
            <summary>Core database and customisation version information.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS">
            <summary>
            Parameter access statuses.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.OK">
            <summary>OK, value was read or written successfully.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.OK_CONVERTED">
            <summary>OK, however the value has been scaled or converted.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.OK_CLAMPED">
            <summary>OK, however value has been clamped to fit inbetween limits.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_ADDRESS_TYPE">
            <summary>Addressing type is not supported.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_TIMEOUT">
            <summary>Timeout.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_ACCESS_DENIED">
            <summary>Access was denied.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_DOES_NOT_EXIST">
            <summary>Parameter/item does not exist.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_DATA_TYPE">
            <summary>The data could not be converted from the specified type.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_READ">
            <summary>Failed to read the parameter/item.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_WRITE">
            <summary>Failed to write to the parameter/ite, </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_NOT_READABLE">
            <summary>The parameter/item is not readable.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_NOT_WRITEABLE">
            <summary>The parameter/item is not writeable.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_OVER_RANGE">
            <summary>The value was outside the range allowed for the parameter/item.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_REQUEST_INVALID">
            <summary>The request contained invalid information.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_RESPONSE_TOO_BIG">
            <summary>Response was too big to fit in the maximum permitted response size.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.FAIL_DECIMAL_PLACE">
            <summary>Decimal places information is not valid.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_DATA">
            <summary>
            The supported parameter data types.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_FILE_STATUS">
            <summary>
            File operation statuses as defined in eCMP.
            Targets may return platform specific values not listed here (e.g. GT8 uses 112-118 as OK_BUT_WARNINGS_n).
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.OK">
            <summary>OK.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.OK_MORE_DATA">
            <summary>OK, but more data is available.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.OK_EOF">
            <summary>OK and the end of the file has been reached.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.OK_PLATFORM_SPECIFIC_RANGE_START">
            <summary>OK. Start of the platform/device specific status codes.</summary>        
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.OK_PLATFORM_SPECIFIC_RANGE_END">
            <summary>OK. End of the platform/device specific status codes.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_INVALID_FILE_HANDLE">
            <summary>Invalid file handle.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_BLOCKED">
            <summary>Another non-blocking operation is already in progress.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_BLOCKING_MODE_NOT_SUPPORTED">
            <summary>The requested blocking mode is not supported.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_NO_OPERATION_IN_PROGRESS">
            <summary>No operation is in progress.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_FILE_NOT_FOUND">
            <summary>The specified file does not exist.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_READ_ONLY">
            <summary>The file could not be opened for writing as it is read-only.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_WRITE_ONLY">
            <summary>The file could not be opened for reading as it is write-only.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_NOT_CREATED">
            <summary>File could not be created for writing.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_NO_DATA">
            <summary>There is no more data to be read from the file.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_WRONG_MODE">
            <summary>The file is not open in the right mode for the requested operation.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_TOO_BIG">
            <summary>Data can't be written as the file is too big or there is no more space.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_PROTECTED">
            <summary>The requested operation cannot be performed on this file. (E.g. file is password protected or protected from deletion.)</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_CRC">
            <summary>The calculated CRC does not match the supplied CRC.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_LENGTH">
            <summary>Calculated length does not match the supplied length.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_TOO_MANY_OPEN">
            <summary>File could not be opened as there are already the maximum number of files open.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_INVALID_FILE">
            <summary>The requested file is invalid or corrupt.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_INVALID_REQUEST">
            <summary>The request could not be processed.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_NO_APPEND">
            <summary>The file could not be opened for appending.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_INVALID_STATE">
            <summary>The file could not be opened for write access as the device is in an invalid state for the operation.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_INCOMPATIBLE">
            <summary>THe file is not compatible with the device.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_TIMEOUT">
            <summary>The operation timed out</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_UNINITIALIZED">
            <summary>The file system is not ready for the request.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_PATH_TOO_LONG">
            <summary>The file path is too long.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_CANCELLED">
            <summary>The operation was cancelled</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_FILE_MODE">
            <summary>
            File access modes.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_MODE.INFO">
            <summary>Open file or directory for information</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_MODE.READ">
            <summary>Open file for reading.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_MODE.CREATE">
            <summary>Create a new file for writing, if the file already exists it will be replaced.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_MODE.APPEND">
            <summary>Opens a file for appending data to. If the file doesn't exist it will be created.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_MODE.CREATE_DIRECTORY">
            <summary>Create a new directory and leave it open in the Info state.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME">
            <summary>
            The parameter addressing scheme. Also includes variables so doesn't have the best name.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.STANDARD" -->
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.SLOT_SPECIFIC">
            <summary>
            Access parameters in a specific slot.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.VARIABLE">
            <summary>
            User variable. This is generally unsupported by target devices.
            </summary>        
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.NULL">
            <summary>
            Used when needing to specify gaps in data mappings for cyclic data. Not of use with normal parameter Read/Write operations.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.CANOPEN_OD">
            <summary>
            Used to specify a CANopen object dictionary Index and Sub-Index
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.PARAMETER_BLOCK">
            <summary>
            Access parameters in a block by specifying the start parameter and a number of consecutive parameters. 
            All parameters must be the same data type and contiguous.
            </summary>
            <remarks>
            Typically this is for use in cyclic data mappings. Not all devices will support this in parameter read/write operations.
            (Introduced in eCMP Specification V1.0)
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.PARAMETER_BLOCK_ELEMENT">
            <summary>
            Used in conjunction with the Parameter Block mapping. Provides
            description attributes to each parameter within a block.
            (Introduced in eCMP Specification V1.0)
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE">
            <summary>
            File attributes used with the FileInfo ECMP message.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE.FILE_LENGTH">
            <summary>The file length in bytes.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE.INTEGRITY">
            <summary>Check the integrity of a file (good or bad).</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE.CRC32">
            <summary>The CRC32 of the file.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE.ATTRIB">
            <summary>The attributes of the file (FAT file system).</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE.CDATE">
            <summary>The creation date (seconds since epoch).</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE.MDATE">
            <summary>The modified date (seconds since epoch).</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE">
            <summary>
            ECMP Attribute IDs.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.MANUFACTURER_NAME">
            <summary>Manufacturer's name.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.PRODUCT_FAMILY">
            <summary>Product family.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.PRODUCT_MODEL">
            <summary>Product model.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.SERIAL_NUMBER">
            <summary>Serial number.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.ORDER_NUMBER">
            <summary>Order number.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.DATE_CODE">
            <summary>Date code.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.DEVICE_NAME">
            <summary>The device's name.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.VERSION_SUMMARY">
            <summary>Version information string.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.COLOUR_CODES">
            <summary>Colour codes.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.SHORT_NAME">
            <summary>Short name.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_ATTRIBUTE.SHORT_STATUS">
            <summary>Short status.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_IDENTIFY_CATEGORY">
            <summary>
            Category of device.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_CATEGORY.DRIVE">
            <summary>A drive.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_CATEGORY.OPTION_MODULE">
            <summary>A option module.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_IDENTIFY_CATEGORY.CANOPEN_PROFILE">
            <summary>Device supporting CANopen profile</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_REQUEST_MODE.SET">
            <summary>
            Set the specified attributes – Attributes must be writeable state
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_REQUEST_MODE.GET">
            <summary>
            Read the specified attributes.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE">
            <summary>
            Sync info attributes that may be used with a <see cref="T:ControlTechniques.CommsServer.EcmpSyncInfoGetRequest"/> or
            <see cref="T:ControlTechniques.CommsServer.EcmpSyncInfoSetRequest"/>. Some attributes are read-only (so can only be used in 
            a get request) and are marked with the <see cref="T:System.ComponentModel.ReadOnlyAttribute"/>.
            
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.SYNC_STATUS">
            <summary>
            Sync Status. Read-only.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.GRANDMASTER_EUI">
            <summary>
            64bit Extended Unique Identifier specified by IEEE. Read-only.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.MOTION_CYCLE_TIME">
            <summary>
            Motion cycle time in nS. Read-only.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.JITTER_FROM_GM">
            <summary>
            Synchronisation jitter in ns. Read-only.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.JITTER_THRESHOLD">
            <summary>
            Tolerable clock jitter in ns from the grandmaster. Read/write.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.PTP_TIME">
            <summary>
            Seconds since 1st Jan, 1970. Read-only.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.PROTOCOL_LAYER">
            <summary>
            Protocol Layer. Read/write.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.DELAY_METHOD">
            <summary>
            Delay Method. Read/write.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.ONE_STEP_TWO_STEP">
            <summary>
            1 step or 2 step. Read/write.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.INHIBIT_DRIVE_SYNC">
            <summary>
            Controls whether the module synchronises the OPT_SYNC with the network grandmaster. Read/write.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.PREFERRED_SYNC_MASTER">
            <summary>
            Module will be preferred as the grandmaster over others with higher preferred values or none specified. Read/write.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.CLOCK_DOMAIN">
            <summary>
            Clock domain of the module. Read/write.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.SYNC_STABLE_WINDOW">
            <summary>
            Duration in milliseconds jitter must be below threshold for clock to be regarded as in sync. Read/write.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ATTRIBUTE.IS_GRANDMASTER">
            <summary>
            Status to report if device is currently a time
            grandmaster on its network
            Value 0 for 'not grandmaster'
            Value 1 for 'is grandmaster'
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_PROTOCOL_LAYER.LAYER_802_3">
            <summary>
            802.3 Protocol Layer
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_PROTOCOL_LAYER.LAYER_UDP">
            <summary>
            UDP Protocol Layerl
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ONE_STEP_TWO_STEP.TWO_STEPS">
            <summary>
            Two Steps
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_ONE_STEP_TWO_STEP.ONE_STEP">
            <summary>
            One Step
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_DELAY_METHOD.DELAY">
            <summary>
            Delay
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_DELAY_METHOD.PATH_DELAY">
            <summary>
            Path Delay
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_OVERALL_STATUS.OK">
            <summary>
            No problem.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_OVERALL_STATUS.OK_WITH_FAILURES">
            <summary>
            Some requests are failed
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_OVERALL_STATUS.OK_PARTIALLY_COMPLETED">
            <summary>
            Device is synchronised to a master or slave device.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_OVERALL_STATUS.OK_NUMBER_MISMATCH">
            <summary>
            The number of attributes is greater than the data provided.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_OVERALL_STATUS.INVALID_MODE">
            <summary>
            The mode requested is invalid
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_OVERALL_STATUS.FAILS">
            <summary>
            All attribute requests fails
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_STATUS.OK">
            <summary>
            The request was processed successfully.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_STATUS.ATTRIBUTE_NOT_FOUND">
            <summary>
            Attribute not found
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_STATUS.READ_ONLY_ATTRIBUTE">
            <summary>
            Read-only attribute
            </summary>
            <remarks>
            A status for Set Mode
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_STATUS.INVALID_DATA_LENGTH">
            <summary>
            Invalid data length
            </summary>
            <remarks>
            A status for Set Mode
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_STATUS.OUT_OF_RANGE">
            <summary>
            Out of range
            </summary>
            <remarks>
            A status for Set Mode
            </remarks>        
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_STATUS.NOT_SUPPORTED">
            <summary>
            Not supported
            </summary>
            <remarks>
            A status for Set Mode. The choice is valid but not supported in current configuration.
            </remarks>        
        </member>
        <member name="F:ControlTechniques.CommsServer.T_SYNC_INFO_STATUS.UNKNOWN_FAILURE">
            <summary>
            Unknown Failure
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.CREATE">
            <summary>
            Create the specified link
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.EDIT">
            <summary>
            Edit the link configuration
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.FINALISE">
            <summary>
            Verify configuration and set to running
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.DELETE">
            <summary>
            Delete the specified link configuration
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.EXIST">
            <summary>
            Check if the specified link number exists
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.LIST">
            <summary>
            List all the available links
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.INFO">
            <summary>
            Get system specific details, link number is ignored
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.SET">
            <summary>
            Set the specified attributes - Link must be in <see cref="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.EDIT"/> mode
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.GET">
            <summary>
            Read the specified attributes
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_MODE.GET_MAPPINGS">
            <summary>
            Reads the mappings for the link
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.STATE">
            <summary>
            Current Link State
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.LINK_DIRECTION">
            <summary>
            This link is configured for receiving or transmitting. RX/TX
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.SYNCHRONISED">
            <summary>
            This link is synchronised to the motion cycle
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MOTION_ENGINE_CYCLE_OFFSET">
            <summary>
            The offset in nanoseconds from the start of the motion cycle that data should be processed
            </summary>
            <remarks>
            This is the point received data should be written and transmitted data should be sampled.
            If not specified default value is 0
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.SAMPLE_PERIOD">
            <summary>
            The time between each sampling of cyclic data.
            </summary>
            <remarks>
            For synchronised links this must be a multiple of all receiving nodes motion cycle periods.
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MOTION_ENGINE_CYCLE_DELAY">
            <summary>
            The offset from the start of the motion cycle the data was sampled in to the start of the motion cycle the receiving node must use the data.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.DATA_CHANGE">
            <summary>
            Only transmit data if it has changed
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.RX_TIMEOUT_HANDLER">
            <summary>
            Rx Timeout Handler
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.RX_LATE_DATA_HANDLER">
            <summary>
            Rx Late Data Handler
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.TRANSPORT_ADDRESS">
            <summary>
            TX – Destination address
            RX – Source address (broadcast or multicast only)
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAX_MAPPINGS">
            <summary>
            Maximum number of mappings. 
            </summary>
            <remarks>
            Can only be set during link creation.
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.NUMBER_OF_MAPPINGS">
            <summary>
            The current number of mappings specified.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAPPING_ITEM">
            <summary>
            A mapping item describes the source / destination of data to be mapped in to the process image.
            </summary>
            <remarks>
            The addressing scheme is the same as that used by the parameter commands in section 7.
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.SAVEABLE">
            <summary>
            Whether the link will persist after a module reset.
            This is not used with new type 0x33 cyclic link.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.LINK_STATUS">
            <summary>
            Status as defined by register 10.1. To clear status bits write to this register with corresponding bit set
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.LINK_NAME">
            <summary>
            ASCII name for the link. 
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAPPING_NAME">
            <summary>
            ASCII name for an individual mapping 
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.TAG">
            <summary>
            Tag used by configuration software to detect changes made to links once initialization of the 
            device and therefore its stored configuration has completed. Value shall be non-zero set by 
            configuration tool. Any further change shall set tag to zero. Tag value defaults to zero if not set.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.STATUS_COUNTER_1">
            <summary>
            Status counters for bits 1 to 31 as defined by 10.1.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.APPLIED_MEC_DELAY">
            <summary>
            This is the actual delay calculated by the device
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAX_RX_LINKS">
            <summary>
            Maximum number of receive links possible in the system
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAX_TX_LINKS">
            <summary>
            Maximum number of transmit links possible in the system
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAX_MAPPINGS_PER_LINK">
            <summary>
            Maximum number of mappings that can be added to a link
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAX_SYNC_RX_LINKS">
            <summary>
            Maximum number of synchronous receive links possible in the system
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAX_SYNC_TX_LINKS">
            <summary>
            Maximum number of synchronous transmit links possible in the system
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MAX_MAPPINGS_PER_SYNC_LINK">
            <summary>
            Maximum number of mappings that can be added to a synchronous link
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.PROCESS_AT_QUEUE_DEPTH">
            <summary>
            The depth for the ‘Process At’ queue available to each synchronous receive link
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.MEC_PERIOD">
            <summary>
            Base period of the Motion Engine Cycle in ns
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.GLOBAL_LINK_STATUS">
            <summary>
            Bitwise OR of all configured links LINK_STATUS (14) bits 1-31. Bit 0 is a bitwise AND of all
            bit 0 for all configured links. A 1 for bit 0 in the Global Link Status indicates all links
            are running. A write to this attribute of any value will clear the global link status AND
            ALL configured link status attributes (attribute LINK_STATUS (14)).
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.RESET_LINK_STATUS_COUNTERS">
            <summary>
            Any write to this attribute wshall cause all link status counters (attributes 18 to 48) to
            be cleared. A read shall always return 0.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.SYNCHRONOUS_RX_MEC_OFFSET">
            <summary>
            A device may advance or retard the
            processing of synchornous recieve links.
            This attribute describes the magnitude in
            nanoseconds and direction (+ is advance,
            - is retard)
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_ATTRIBUTE.SYNCHRONOUS_TX_MEC_OFFSET">
            <summary>
            A device may advance or retard the pro-
            cessing of synchornous transmit links.
            This attribute describes the magnitude in
            nanoseconds and direction (+ is advance,
            - is retard)
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_TRANSPORT_ADDRESSING_SCHEME.IPV4">
            <summary>
            The message will use IPv4 transport
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.OK">
            <summary>
            The request was processed successfully. (Not for Create mode)
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.OK_AND_EDITABLE">
            <summary>
            The request was processed and the link is in edit state.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.FAILED_TO_ALLOCATE_MEMORY">
            <summary>
            Failed to allocate memory
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.CREATE_FAILED_MAX_LINKS">
            <summary>
            Create link failed as max links has been met
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.INVALID_ARGUMENTS">
            <summary>
            Invalid arguments
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.INVALID_LINK_NUMBER">
            <summary>
            Link number must be non-zero
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.LINK_NOT_IN_EDIT_STATE">
            <summary>
            The requested operation requires the link to be in the EDIT state
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.LINK_NUMBER_IN_USE">
            <summary>
            Failed to create a link with the specified link number as the number is already in use.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.LINK_IN_ERROR">
            <summary>
            An error has occurred while validating the link
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.TIMEOUT">
            <summary>
            Operation timed out.
            </summary>
            <remarks>
            The requested operation was not performed.
            </remarks>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.ATTRIBUTE_MISSING">
            <summary>
            The requested Mode required an attribute that was missing
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.ATTRIBUTE_READ_ONLY">
            <summary>
            Read only attributes cannot be set
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.ATTRIBUTE_NOT_AVAILABLE">
            <summary>
            The attribute exists but cannot be accessed by the specified mode
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.LINK_FRAME_TOO_LONG">
            <summary>
            Link Frame Too Long
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.LINK_NUMBER_AND_DIRECTION_NOT_MATCHING">
            <summary>
            Specified link number is not matching with the specified link direction.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.MAPPING_READ_ONLY">
            <summary>
            A mapping which is read only has been mapped as a destination for new data
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.MAPPING_DOES_NOT_EXIST">
            <summary>
            The mapping points to an item that does not exist
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.INVALID_PROFILE">
            <summary>
            The profile specified was invalid
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.LINK_BUSY">
            <summary>
             The requested mode was unable to be performed as the system is currently busy. Retry the request.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.TOO_MANY_MAPPINGS">
            <summary>
            Too many mapppings.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.INVALID_TX_PERIOD">
            <summary>
             The transmission period is not valid for the link type.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.MEC_OFFSET_ERROR">
            <summary>
            MEC offset error.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.SYNC_NOT_SUPPORTED">
            <summary>
            A synchronous specific operation was attempted when synchronised links are not supported.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.INVALID_IP_ADDRESS">
            <summary>
             The IP address for the destination is invalid.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.VLAN_DISABLED">
            <summary>
            VLAN is disabled.
            Synchronous functionality relies on a prioritised network to guarantee cyclic latency bounds. 
            VLAN offers frame tagging and must be enabled when utilising synchronous cyclic links.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.DISABLED">
            <summary>
            Link disabled.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATUS.MCAST_OVER_LIMIT">
            <summary>
            No multicast address found.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE">
            <summary>
            Current operational state of a link.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.NOT_IN_USE">
            <summary>Link not in use</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.EDIT">
            <summary>Link in edit state</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.VALIDATE">
            <summary>Link validating</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.RUNNING">
            <summary>Link running (non-synchronous)</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.RUNNING_SYNC">
            <summary>Link running (synchronous)</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.ERROR">
            <summary>Link in error</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.DELETING">
            <summary>Link is being deleted.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.RUNNING_PREOP">
            <summary>Preoperational running state.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_CYCLIC_LINK_STATE.RUNNING_SYNC_PREOP">
            <summary>Preoperational running synchronous state.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_CYCLIC_LINK_LINK_DIRECTION">
            <summary>
            RX/TX Link Direction
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_DIAGNOSTIC_ATTRIBUTE.MONITORED_TASKS">
            <summary>
            NGA Only - Gets the running timed takes and any resource information
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_DIAGNOSTIC_ATTRIBUTE.RUNTIME_STATUS">
            <summary>
            NGA Only - Gets the status of the runtime and any tasks that have an error
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_DIAGNOSTIC_ATTRIBUTE.SYSTEM_STATUS">
            <summary>
            NGA Only - Gets the overall % of used flash file sysytem
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_DEVICE_STATUS">
            <summary>
            Device Status
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_DEVICE_STATUS.FAULT">
            <summary>
            Bit 0 - On if fault
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_DEVICE_STATUS.ALARM">
            <summary>
            Bit 1 - On if alarm
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_DEVICE_STATUS.RUN">
            <summary>
            Bit 2 - On if running
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_DEVICE_STATUS.CONFIG_VALID">
            <summary>
            Bit 3 - On if configuration valid
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_DEVICE_STATUS.NETWORK_ACTIVE">
            <summary>
            Bit 4 - On if the network is active. Off is not, if inactive the attribte T_DIAGNOSTIC_ATTRIBUTE.NETWORK_STATUS will give further details
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.T_PARAMETER_UNITS">
            <summary>
            Standard unit definitions.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.T_PARAMETER_UNITS.CUSTOM">
            <summary>
            Custom units. The value of CUSTOM1 may also be used by targets.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileCloseMessageRequest">
            <summary>
            A File Close request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileCloseMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileCloseMessageRequest.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileCloseMessageRequest.FileDataLength">
            <summary>
            The data length of the uploaded or downloaded file.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileCloseMessageRequest.CRC">
            <summary>
            The CRC calculates for the uploaded or downloaded data.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileCloseMessageRequest.FileHandle">
            <summary>
            The handle of the file being closed.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileCloseMessageResponse">
            <summary>
            An File Close response.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileCloseMessageResponse.OK">
            <summary>
            Returns True if the Status indicates the file closed successfully, false if a problem occurred.
            If True is returned, Status should still be checked for any platform specific success codes.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileDeleteMessageRequest">
            <summary>
            A File Delete request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileDeleteMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileDeleteMessageRequest.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileDeleteMessageResponse">
            <summary>
            An File Delete response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileExistsMessageRequest">
            <summary>
            A File exists request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileExistsMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileExistsMessageResponse">
            <summary>
            A File Exists message response.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileExistsMessageResponse.Response">
            <summary>
            The user response object.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileInfoMessageRequest">
            <summary>
            A File Info request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileInfoMessageRequest.CreateFileInfo(System.Int32,ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE)">
            <summary>
            Method for creating a single file info attribute request.
            </summary>
            <param name="FileHandle"></param>
            <param name="AttribType"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileInfoMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileInfoMessageResponse">
            <summary>
            An File Read response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileInfoRequest">
            <summary>
            Request information on a file.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileInfoRequest.#ctor">
            <summary>
            Constructor. Remember to populate <see cref="P:ControlTechniques.CommsServer.FileInfoRequest.RequestedAttributes"/>.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileInfoRequest.#ctor(System.String,ControlTechniques.CommsServer.T_FILE_ATTRIBUTE_TYPE)">
            <summary>
            Constructor.
            </summary>
            <param name="filename">Filename on target device.</param>
            <param name="attr">Attribute you required. This is added to the <see cref="P:ControlTechniques.CommsServer.FileInfoRequest.RequestedAttributes"/> list.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileInfoRequest.TargetFileName">
            <summary>
            Filename on the target device.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileInfoRequest.RequestedAttributes">
            <summary>
            The attributes you require. The number you can ask for at a time is dependant upon what the target device supports.
            For maximum compatibility only request one.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileInfoResponse">
            <summary>
            Response to a file info request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileInfoResponse.#ctor(ControlTechniques.CommsServer.FileInfoRequest)">
            <summary>
            Constructor.
            </summary>
            <param name="TheRequest"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileInfoResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileInfoResponse.Status">
            <summary>
            Overall status.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileInfoResponse.FileAttributes">
            <summary>
            The returned attributes. This may be <c>null</c> or empty if no data was received from the target.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileOpenMessageRequest">
            <summary>
            A File Open request.
            Use the static methods to create the appropriate request for the mode of opening, i.e. Read, Write or Info.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileOpenMessageRequest.CreateFileInfoMessage(System.String)">
            <summary>
            Create message to open a file in "Info" mode.
            </summary>
            <param name="FileName">The file to open.</param>
            <returns>Message request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileOpenMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileOpenMessageRequest.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileOpenMessageResponse">
            <summary>
            A FileOpen message response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileReadMessageRequest">
            <summary>
            A File Read request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileReadMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileReadMessageRequest.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileReadMessageRequest.RequestedBytes">
            <summary>
            This will be clamped to ECMPTxRxLayer.MaxTransmitBuffer (320) bytes.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileReadMessageRequest.RequestLength">
            <summary>
            Returns the number of bytes of the request.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileReadMessageResponse">
            <summary>
            An File Read response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileWriteMessageRequest">
            <summary>
            A File Write request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileWriteMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPFileWriteMessageRequest.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPFileWriteMessageRequest.RequestLength">
            <summary>
            Returns the number of bytes of the request.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPFileWriteMessageResponse">
            <summary>
            An File Read response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPGetNextObjectsMessageRequest">
            <summary>
            A GetNextObjects message request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPGetNextObjectsMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPGetNextObjectsMessageResponse">
            <summary>
            An Info message response.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPGetNextObjectsResponse.OverallStatus">
            <summary>
            The status code if the entire request failed. This should only be referred to if the <see cref="P:ControlTechniques.CommsServer.ECMPGetNextObjectsResponse.ValueReturned"/> is false.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPIdentifyMessageRequest">
            <summary>
            An Identify message request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPIdentifyMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPIdentifyMessageRequest.TimeoutMs">
            <summary>
            The default timeout for the message.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPIdentifyMessageResponse">
            <summary>
            An Info message response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPIdentifyResponse">
            <summary>
            Response to an <see cref="T:ControlTechniques.CommsServer.ECMPIdentifyRequest"/>. Provides device identification and attribute data.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Category">
            <summary>
            This field indicates which of the following properties are relevant in the response.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.ProductType">
            <summary>
            Indicates the product type. Valid only if the <see cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Category"/> is <see cref="F:ControlTechniques.CommsServer.T_IDENTIFY_CATEGORY.DRIVE"/>. For any other category the value is invalid.
            The value of this field is taked from #11.063 on GT8.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.DriveDerivative">
            <summary>
            Indicates the drive derivative. Valid only if the <see cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Category"/> is <see cref="F:ControlTechniques.CommsServer.T_IDENTIFY_CATEGORY.DRIVE"/>. For any other category the value is invalid.
            The value of this field is taked from #11.028 on GT8.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.OptionID">
            <summary>
            If the Category property is DRIVE_CATEGORY, this field indicates the Factory Fit Option ID - from #24.01.
            If the Category property is OPTION_CATEGORY, this field indicates the Option ID - from #15.01, #16.01 or #17.01.
            Any other category this field is not valid.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.CANopenProfileId">
            <summary>
            Profile identifier for CANopen category of device.
            Valid only if the <see cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Category"/> is <see cref="F:ControlTechniques.CommsServer.T_IDENTIFY_CATEGORY.CANOPEN_PROFILE"/>.        
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.PrimaryColour">
            <summary>
            Primary Colour, typically Bezel/Bib
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.SecondaryColour">
            <summary>
            Secondary Colour, typically body
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Attributes">
            <summary>
            The attribute type.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Attribute">
            <summary>
            Legacy property.
            Getting the property gets the first item from the <see cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Attributes"/> list.
            Setting the property clears the <see cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.Attributes"/> list and adds the value in as the only item.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.AttributesData">
            <summary>
            The attribute data.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.AttributeData">
            <summary>
            Legacy property. 
            Getting the property returns the first item of the <see cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.AttributesData"/> list.
            Setting the property clears the <see cref="P:ControlTechniques.CommsServer.ECMPIdentifyResponse.AttributesData"/> list and adds the value as the only item.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInfoMessageRequest">
            <summary>
            An Info message request.
            </summary>    
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPInfoMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInfoMessageResponse">
            <summary>
            An Info message response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInfoRequest">
            <summary>
            Information request - used to determine the communication limits of a device.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPInfoResponse"/>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPInfoResponse">
            <summary>
            Info response. Contains information relating to the communication limits of a device.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPInfoResponse.#ctor(ControlTechniques.CommsServer.ECMPInfoRequest)">
            <summary>
            Constructor.
            </summary>
            <param name="TheRequest">Request.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInfoResponse.Request">
            <summary>
            The request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInfoResponse.BufferSizeBytes">
            <summary>
            Size of buffer used to receive ECMP request frames in bytes. A request sent to a device must not exceed this length.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInfoResponse.MaxResponseTimeMs">
            <summary>
            The maximum time in milliseconds that a client should wait for a response.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPInfoResponse.MaxHandlePeriods">
            <summary>
            Maximum number of response time periods allowed before a request is aborted. A value of 0 means no information about maximum handling time is available.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPObjectInfoMessageRequest">
            <summary>
            An Info message request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPObjectInfoMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPObjectInfoMessageResponse">
            <summary>
            An Info message response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPObjectInfoRequest">
            <summary>
            Request for object (e.g. menu or parameter) information.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPObjectInfoRequest.#ctor">
            <summary>
            Constructor. This will default to requesting <see cref="F:ControlTechniques.CommsServer.T_INFO_TYPE.MAX_IN_MENU"/> for the direct address and menu 0.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPObjectInfoRequest.#ctor(ControlTechniques.CommsServer.T_INFO_TYPE,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="infoType">Item to request info on.</param>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPObjectInfoRequest.#ctor(ControlTechniques.CommsServer.T_INFO_TYPE,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <remarks>
            Please note that not all devices will support slot addressing.
            </remarks>
            <param name="infoType">Item to request info on.</param>
            <param name="slot">Slot number.</param>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoRequest.InfoType">
            <summary>
            The type of information required.
            </summary>        
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoRequest.Slot">
            <summary>
            The slot number.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoRequest.Menu">
            <summary>
            The menu number. Usage depends on <see cref="P:ControlTechniques.CommsServer.ECMPObjectInfoRequest.InfoType"/>.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoRequest.Parameter">
            <summary>
            The parameter number. Usage depends on <see cref="P:ControlTechniques.CommsServer.ECMPObjectInfoRequest.InfoType"/>.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.Request">
            <summary>
            The request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.OverallStatus">
            <summary>
            Overall status if the complete request failed.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.InfoType">
            <summary>
            The type of information returned.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.MenuValue">
            <summary>
            Menu value. 
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.ParamValue">
            <summary>
            Parameter value.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.ParamUnits">
            <summary>
            Parameter units string. Only valid when InfoType T_INFO_TYPE.Units and the <see cref="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.ParamUnitsId"/> is 255.
            </summary>        
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.ParamUnitsId">
            <summary>
            The numeric ID of the units for a parameter. These are be device specific.
            A value of 255 indicates a custom units string may be available in the <see cref="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.ParamUnits"/> property.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.MenuVersion">
            <summary>
            Version number (when used with <see cref="F:ControlTechniques.CommsServer.T_INFO_TYPE.MENU_CUSTOMISATION_INFO"/> request).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.MenuCRC">
            <summary>
            Menu CRC (when used with <see cref="F:ControlTechniques.CommsServer.T_INFO_TYPE.MENU_CUSTOMISATION_INFO"/> request).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPObjectInfoResponse.DatabaseVersion">
            <summary>
            Database version information.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPObjectInfoResponse.DatabaseVersionInfo">
            <summary>
            Database version information data type.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPReadMessageRequest">
            <summary>
            An Info message request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadMessageRequest.UserRequestFromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstruct a request from bytes.
            </summary>
            <param name="b">Buffer.</param>
            <param name="from">Buffer pointer.</param>
            <returns>The request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPReadMessageResponse">
            <summary>
            An Info message response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPReadRequest">
            <summary>
            Read request for reading a parameter or other object.
            Note that values read back will not have information such as decimal places. For a more complete read, use <see cref="T:ControlTechniques.CommsServer.ECMPReadWithTypeRequest"/>.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPReadWithTypeRequest"/>.
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadRequest.#ctor">
            <summary>
            Constructs an empty read request. Populate the <see cref="P:ControlTechniques.CommsServer.ECMPReadRequest.Parameters"/> property with items to read.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadRequest.#ctor(System.Collections.Generic.List{ControlTechniques.CommsServer.ParameterID})">
            <summary>
            Constructs an read request for a list of parameters.
            </summary>
            <param name="parameters">Parameter list.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadRequest.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an read request for a single parameter. More parameters can be added by adding items to <see cref="P:ControlTechniques.CommsServer.ECMPReadRequest.Parameters"/>.
            </summary>
            <param name="menu">menu number.</param>
            <param name="parameter">Parameter number.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadRequest.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an read request for a single parameter. More parameters can be added by adding items to <see cref="P:ControlTechniques.CommsServer.ECMPReadRequest.Parameters"/>.
            </summary>
            <param name="slot">Slot number.</param>
            <param name="menu">menu number.</param>
            <param name="parameter">Parameter number.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadRequest.IsSingleAddressingScheme">
            <summary>
            Checks if only a single addressing scheme is in use.
            </summary>
            <returns><c>True</c> if single addressing scheme.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadRequest.Parameters">
            <summary>
            The parameters in the request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadRequest.AddressingScheme">
            <summary>
            Gets the addressing scheme for the parameters. A <see cref="T:System.ApplicationException"/> will be thrown if there are parameters with different parameter
            addressing schemes in the <see cref="P:ControlTechniques.CommsServer.ECMPReadRequest.Parameters"/> collection.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPReadResponse">
            <summary>
            Response to a <see cref="T:ControlTechniques.CommsServer.ECMPReadRequest"/>.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadResponse.ParameterValues">
            <summary>The parameter values returned.</summary>
            <remarks>
            If the list has zero items in it the request failed and you need to refer to <see cref="P:ControlTechniques.CommsServer.ECMPReadResponse.OverallStatus"/> for the reason.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadResponse.OverallStatus">
            <summary>
            The status code if the entire request failed. This should only be referred to if the <see cref="P:ControlTechniques.CommsServer.ECMPReadResponse.ParameterValues"/> list is empty.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPReadWithTypeMessageRequest">
            <summary>
            An Info message request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadWithTypeMessageRequest.UserRequestFromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstruct a request from bytes.
            </summary>
            <param name="b">Buffer.</param>
            <param name="from">Buffer pointer.</param>
            <returns>The request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadWithTypeMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadWithTypeMessageRequest.Request">
            <summary>
            The parameters in the request.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPReadWithTypeMessageResponse">
            <summary>
            An Info message response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPReadWithTypeRequest">
            <summary>
            Read a parameter or object with type information (such as number of decimal places in the value).
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPReadRequest"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.#ctor">
            <summary>
            Constructs an empty read request. Populate the <see cref="P:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.Parameters"/> property with items to read.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an read request for a single parameter. More parameters can be added by adding items to <see cref="P:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.Parameters"/>.
            </summary>
            <param name="slot">Slot number.</param>
            <param name="menu">menu number.</param>
            <param name="parameter">Parameter number.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an read request for a single parameter. More parameters can be added by adding items to <see cref="P:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.Parameters"/>.
            </summary>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.#ctor(System.Collections.Generic.List{ControlTechniques.CommsServer.ParameterID})">
            <summary>
            Constructs an read request for a list of parameters.
            </summary>
            <param name="parameters">Parameter list.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.ToString">
            <summary>
            Return a string representation. Note this may not accurately show all parameter data.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.IsSingleAddressingScheme">
            <summary>
            Checks if only a single addressing scheme is in use.
            </summary>
            <returns><c>True</c> if single addressing scheme.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.Parameters">
            <summary>
            The parameters in the request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.AddressingScheme">
            <summary>
            Gets the addressing scheme for the parameters. A <see cref="T:System.ApplicationException"/> will be thrown if there are parameters with different parameter
            addressing schemes in the <see cref="P:ControlTechniques.CommsServer.ECMPReadWithTypeRequest.Parameters"/> collection.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPReadWithTypeResponse">
            <summary>
            Response to a <see cref="T:ControlTechniques.CommsServer.ECMPReadWithTypeRequest"/>.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadWithTypeResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadWithTypeResponse.ParameterValues">
            <summary>The parameter values returned.</summary>
            <remarks>
            If the list has zero items in it the request failed and you need to refer to <see cref="P:ControlTechniques.CommsServer.ECMPReadWithTypeResponse.OverallStatus"/> for the reason.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPReadWithTypeResponse.OverallStatus">
            <summary>
            The status code if the entire request failed. This should only be referred to if the <see cref="P:ControlTechniques.CommsServer.ECMPReadWithTypeResponse.ParameterValues"/> list is empty.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ResetType">
            <summary>
            Reset types.
            The meaning of this will be target dependant. Certain targets may not support all values or may support values not in this list.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPResetMessageRequest">
            <summary>
            A reset message.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPResetMessageRequest.UserRequestFromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstruct a request from bytes.
            </summary>
            <param name="b">Buffer.</param>
            <param name="from">Buffer pointer.</param>
            <returns>The request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPResetMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPResetMessageRequest.PostTxDelayMs">
            <summary>
            The default delay after transmission before a following transmission should take place.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPResetMessageResponse">
            <summary>
            An reset message.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPResetRequest">
            <summary>
            Resets a device - fully or partially.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPResetRequest.#ctor">
            <summary>
            Constructor. Initialises the <see cref="P:ControlTechniques.CommsServer.ECMPResetRequest.ResetType"/> to <see cref="F:ControlTechniques.CommsServer.ResetType.Full"/>.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPResetRequest.#ctor(ControlTechniques.CommsServer.ResetType)">
            <summary>
            Constructor. Initialises the <see cref="P:ControlTechniques.CommsServer.ECMPResetRequest.ResetType"/> to the requested value.
            </summary>
            <param name="resetType"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPResetRequest.ResetType">
            <summary>
            The type of reeset required. The meaning of this is dependant upon the target device.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPResetResponse">
            <summary>
            Response to a <see cref="T:ControlTechniques.CommsServer.ECMPResetRequest"/>.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPResetResponse.Request">
            <summary>
            The request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPResetResponse.ResetType">
            <summary>
            Reset type.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPResetResponse.ResetStatus">
            <summary>
            Status.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ControlTechniques.CommsServer.ECMPTxRxLayer" -->
        <member name="F:ControlTechniques.CommsServer.ECMPTxRxLayer.meCMP">
            <summary>
            The eCMP Rx/ Tx engine.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPTxRxLayer.mTransaction">
            <summary>
            The eCMP transaction number.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.#ctor">
            <summary>
            Construct the transmit/ receive layer.
            </summary>
            <param name="WindowHandle"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.Stop">
            <summary>
            Stops comms and deregisters from the CommsServer.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.StartEthernet(System.Int32,System.Int32)">
            <summary>
            Register with the comms server (Win messaging notification) and begin doing Ethernet comms.
            
            Return true if the registration is successful.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.StartRTU(System.Int32,System.Int32,System.Int32,ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE)">
            <summary>
            Register with the comms server (Win messaging notification) and begin doing RTU comms.
            
            Return true if the registration is successful.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.GetHeaderLength(ControlTechniques.CommsServer.CommsAddress)">
            <summary>
            This returns the number of bytes the ECMP header takes for a given target address.
            </summary>
            <param name="address">Address.</param>
            <returns>Number of bytes header takes.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.ECMPHeader(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Byte[]@,System.Int32@)">
            <summary>
            Creates an ECMP header for a message:
                Adds source/ destination address.
            </summary>
            <param name="Address"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.GetEcmpMessage(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPMessageRequestBase)">
            <summary>
            Gets the complete ECMP message as a byte array.
            </summary>
            <param name="address">Address</param>
            <param name="message">Message.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.ParseECMPHeader(System.Byte[],System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Parses an ECMP message frame returning information such as transaction number and indicating if the
            message is truly for this node. 
            
            After the call, From is set to the index of the first byte of the real data - the internal eCMP frame.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPTxRxLayer.ProcessWindowsMessage(System.Int32,System.Int32)">
            <summary>
            Processes a Windows message notification from the CTCommsServer.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTxRxLayer.MaxTransmitBufferSizeLowerLimit">
            <summary>
            The lower limit of the max transmit buffer size.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTxRxLayer.MaxTransmitBufferSizeUpperLimit">
            <summary>
            The upper limit of the max transmit buffer size.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTxRxLayer.MaxTransmitBuffer">
            <summary>
            The maximum transmit buffer size limit. This value is now the maximum number of bytes of the entire ECMP message that may be transmitted.
            This value must be:
                <see cref="P:ControlTechniques.CommsServer.ECMPTxRxLayer.MaxTransmitBufferSizeLowerLimit"/> &lt;= <see cref="!:MaxTransmitBufferSize"/> &lt;= <see cref="P:ControlTechniques.CommsServer.ECMPTxRxLayer.MaxTransmitBufferSizeUpperLimit"/>.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTxRxLayer.CommsServerUserID">
            <summary>
            The comms server user ID.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPTxRxLayer.TransactionNumber">
            <summary>
            Increments the transaction number and returns the new value;
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPTxRxLayer.T_FAIL_TYPE">
            <summary>
            Indicates the different types of errors that may occur.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPTxRxLayer.ECMPFailHandler">
            <summary>
            Timeout events. Subscribe if interested.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPTxRxLayer.ECMPResponseHandler">
            <summary>
            Message received handler. Subscribe if interested.
            </summary>
            <param name="sender"></param>
            <param name="Response"></param>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPTxRxLayer.T_ECMP_CONSTANTS">
            <summary>
            Constants used in eCMP.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPTxRxLayer.T_ECMP_CONSTANTS.MAX_RESPONSE_SIZE">
            <summary>The default response buffer size.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPTxRxLayer.T_ECMP_CONSTANTS.MAX_RESPONSE_SIZE_UPPER">
            <summary>The maximum allowed response buffer size.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPTxRxLayer.T_ECMP_CONSTANTS.MAX_RESPONSE_SIZE_LOWER">
            <summary>The minimum allowed response buffer size.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPTxRxLayer.T_ECMP_CONSTANTS.MAX_TRANSMIT_SIZE_UPPER">
            <summary>The maximum allowed transmit buffer size.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPTxRxLayer.T_ECMP_CONSTANTS.MAX_TRANSMIT_SIZE">
            <summary>The default transmit buffer size.</summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ECMPTxRxLayer.T_ECMP_CONSTANTS.MAX_TRANSMIT_SIZE_LOWER">
            <summary>The minimum allowed max transmit buffer size.</summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPWriteMessageRequest">
            <summary>
            A write message request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteMessageRequest.UserRequestFromBytes(System.Byte[],System.Int32@)">
            <summary>
            Reconstruct a request from bytes.
            </summary>
            <param name="b">Buffer.</param>
            <param name="from">Buffer pointer.</param>
            <returns>The request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteMessageRequest.MessageID">
            <summary>
            A message must provide its ID for transmission.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteMessageRequest.ToString">
            <summary>
            Output a string showing each menu, param, value in sequence separated by dots and commas 
            </summary>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPWriteMessageResponse">
            <summary>
            An Info message response.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ECMPWriteRequest">
            <summary>
            Write request. Contains a list of parameters to write to a target device together with the value and number of decimal places.
            As a guide, no more than 10 parameters should be written to in one request.
            </summary>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPReadRequest"/>
            <seealso cref="T:ControlTechniques.CommsServer.ECMPReadWithTypeRequest"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteRequest.#ctor">
            <summary>
            Constructs an empty write request.
            </summary>
            <remarks>Parameters to be written are to be added to the <see cref="P:ControlTechniques.CommsServer.ECMPWriteRequest.Parameters"/> property.</remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteRequest.#ctor(System.Int32,System.Int32,ControlTechniques.CommsServer.ParameterValue,System.Int32)">
            <summary>
            Constructor for creating a write request to a single parameter.
            </summary>
            <remarks>Additional parameters can be added by adding new items to the <see cref="P:ControlTechniques.CommsServer.ECMPWriteRequest.Parameters"/> property.</remarks>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number.</param>
            <param name="value">Value to write.</param>
            <param name="dpos">Number of decimal places. E.g. to write a value of 123.4, set dpos to 1.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteRequest.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor for creating a write request to a single parameter with a integer fixed-point value
            </summary>
            <remarks>
            Additional parameters can be added by adding new items to the <see cref="P:ControlTechniques.CommsServer.ECMPWriteRequest.Parameters"/> property.
            </remarks>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number.</param>
            <param name="value">Value to write. The data type will be signed 32-bit (see <see cref="M:ControlTechniques.CommsServer.ParameterValue.CreateINT32Value(System.Int32)"/>).</param>
            <param name="dpos">Number of decimal places. E.g. to write a value of 123.4, set dpos to 1.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteRequest.#ctor(System.Int32,System.Int32,System.Int32,ControlTechniques.CommsServer.ParameterValue,System.Int32)">
            <summary>
            Constructor for creating a write request to a single parameter.
            </summary>
            <remarks>Additional parameters can be added by adding new items to the <see cref="P:ControlTechniques.CommsServer.ECMPWriteRequest.Parameters"/> property.</remarks>
            <param name="slot">Slot number.</param>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number.</param>
            <param name="value">Value to write.</param>
            <param name="dpos">Number of decimal places. E.g. to write a value of 123.4, set dpos to 1.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteRequest.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor for creating a write request to a single parameter with an integer fixed-point value
            </summary>
            <remarks>
            Additional parameters can be added by adding new items to the <see cref="P:ControlTechniques.CommsServer.ECMPWriteRequest.Parameters"/> property.
            </remarks>
            <param name="slot">Slot number.</param>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number.</param>
            <param name="value">Value to write. The data type will be signed 32-bit (see <see cref="M:ControlTechniques.CommsServer.ParameterValue.CreateINT32Value(System.Int32)"/>).</param>
            <param name="dpos">Number of decimal places. E.g. to write a value of 123.4, set dpos to 1.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteRequest.#ctor(ControlTechniques.CommsServer.ParameterID,ControlTechniques.CommsServer.ParameterValue,System.Int32)">
            <summary>
            Constructor for creating a write request to a single parameter.
            </summary>
            <param name="parameter">Parameter identifier.</param>
            <param name="value">Value to write.</param>
            <param name="dpos">Number of decimal places. E.g. to write a value of 123.4, set dpos to 1.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ECMPWriteRequest.IsSingleAddressingScheme">
            <summary>
            Checks if only a single addressing scheme is in use.
            </summary>
            <returns><c>True</c> if single addressing scheme.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPWriteRequest.Parameters">
            <summary>
            The parameters in the request. The number of parameters allowed is dependent upon the capabilities of the target device,
            but as a guide this should be limited to a maximum of 10. All parameters in the list must have the same parameter addressing scheme.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPWriteRequest.AddressingScheme">
            <summary>
            Gets the parameter addressing scheme for the parameters. If the parameter list has mixed addressing scheme an
            <see cref="T:System.ApplicationException"/> will be thrown.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPWriteResponse.Request">
            <summary>
            The write request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPWriteResponse.OverallStatus">
            <summary>
            Overall status of write request if <see cref="P:ControlTechniques.CommsServer.ECMPWriteResponse.ParameterAccessStatuses"/> list is null or empty.
            </summary>
            <remarks>
            This will indicate <see cref="F:ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS.OK"/> if ALL writes also have the status of OK. 
            If this does not indicate OK, clients must refer to <see cref="P:ControlTechniques.CommsServer.ECMPWriteResponse.ParameterAccessStatuses"/> list to
            determine the status of each write.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ECMPWriteResponse.ParameterAccessStatuses">
            <summary>
            Contains a list of status codes for each write.
            If this list is null or empty then the whole write failed - refer to <see cref="P:ControlTechniques.CommsServer.ECMPWriteResponse.OverallStatus"/> for the reason.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FAT32Attrib">
            <summary>
            FAT32 Attributes used in ECMP
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileAccessMode">
            <summary>
            Implement an ECMP file access mode.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileAttributeValue">
            <summary>
            Describes a file attribute.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileAttributeValue.AttribType">
            <summary>
            The value of this type indicates which of the following properties holds sensible data.
            </summary>
        </member>
        <member name="T:ControlTechniques.Comms.ParameterIdentifier">
            <summary>
            Identifies a parameter (internal comms use)
            </summary>
        </member>
        <member name="P:ControlTechniques.Comms.ParameterIdentifier.SlotSpecific">
            <summary>
            Identifies the parameter as being slot specific or not.
            </summary>
        </member>
        <member name="T:ControlTechniques.Comms.ParameterAccessStatus">
            <summary>
            Status of a parameter access.
            Positive values indicate success, negative values indicate failure.
            </summary>
        </member>
        <member name="T:ControlTechniques.Comms.ParameterValue">
            <summary>
            Parameter value base class.
            </summary>
        </member>
        <member name="M:ControlTechniques.Comms.ParameterValue.#ctor(ControlTechniques.Comms.ParameterAccessStatus,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="status"></param>
            <param name="slot"></param>
            <param name="menu"></param>
            <param name="parameter"></param>
        </member>
        <member name="P:ControlTechniques.Comms.ParameterValue.Status">
            <summary>
            Status of any comms action on this parameter.
            </summary>
        </member>
        <member name="P:ControlTechniques.Comms.ParameterValue.Identifier">
            <summary>
            Parameter identifier (slot, menu, parameter number)
            </summary>
        </member>
        <member name="T:ControlTechniques.Comms.IntegerParameterValue">
            <summary>
            Standard integer parameter value.
            </summary>
        </member>
        <member name="T:ControlTechniques.Comms.Integer64ParameterValue">
            <summary>
            64-bit signed parameter value.
            </summary>
        </member>
        <member name="T:ControlTechniques.Comms.UnsignedInteger64ParameterValue">
            <summary>
            64-bit unsigned parameter value.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ParameterID">
            <summary>
            A parameter ID structure - basic menu/ parameter pairing and addressing.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ParameterID.MaxBlockCount">
            <summary>
            Maximum amount of block parameters allowed.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ParameterID.MaxNullDataCount">
            <summary>
            Maximum amount of null data allowed.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ParameterID.DriveOption">
            <summary>
            Constant for specifying the drive in a slot argument.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.ParameterID._nullDataCount">
            <summary>
            Number of null data.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Parameter ID using T_PARAMETER_ADDRESSING_SCHEME.STANDARD as the addressing scheme
            </summary>
            <param name="menu">menu number</param>
            <param name="parameter">parameter number</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.#ctor(System.Int32,System.Int32,ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME)">
            <summary>
            Constructs a Parameter ID using the specified addressing scheme
            </summary>
            <param name="menu">menu number</param>
            <param name="parameter">parameter number</param>
            <param name="addressingScheme"><see cref="T:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME"/> to use</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a Parameter ID using T_PARAMETER_ADDRESSING_SCHEME.SLOT_SPECIFIC as the addressing scheme.
            </summary>
            <remarks>
            To create a parameter block address use the <see cref="M:ControlTechniques.CommsServer.ParameterID.ParameterBlock(System.Int32,System.Int32,System.Int32)"/> static method.
            </remarks>
            <param name="slot">slot number to address</param>
            <param name="menu">menu number</param>
            <param name="parameter">parameter number</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.#ctor(System.Int32,System.Int32,System.Int32,ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME)">
            <summary>
            Constructs a Parameter ID using the specified addressing scheme
            </summary>
            <param name="slot"></param>
            <param name="menu">menu number</param>
            <param name="parameter">parameter number</param>
            <param name="addressingScheme"><see cref="T:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME"/> to use</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.ParameterBlock(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a parameter block address.
            </summary>
            <param name="menu">Starting menu</param>
            <param name="parameter">Starting parameter.</param>
            <param name="count">Number of parameters.</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.Null(System.Int32)">
            <summary>
            Create a NULL address.
            </summary>
            <param name="nullCount">Number of bytes to skip. Should be specified in multiples of 4 (UDINT).</param>
            <returns>ParameterID</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.CANDictionaryObject(System.Int32,System.Int32)">
            <summary>
            Create a CANOpen object dictionary identifier
            </summary>
            <param name="index"></param>
            <param name="subindex"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.Equals(System.Object)">
            <summary>
            Check if one ParameterID is equal in value to another.
            </summary>
            <param name="obj">Other</param>
            <returns><c>true</c> if other parameter ID represents the same thing.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.Equals(ControlTechniques.CommsServer.ParameterID)">
            <summary>
            Check if one ParameterID is equal in value to another.
            </summary>
            <param name="other">Other</param>
            <returns><c>true</c> if other parameter ID represents the same thing.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterID.ToString">
            <summary>
            Returns a string representation.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.AddressingScheme">
            <summary>
            Defines how the parameter is addressed.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.Slot">
            <summary>
            The slot number. Valid only for <see cref="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.SLOT_SPECIFIC"/> addressing scheme.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.Menu">
            <summary>
            Menu number.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.Parameter">
            <summary>
            Parameter number.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.Index">
            <summary>
            Index number (addressing scheme of <see cref="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.CANOPEN_OD"/>).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.SubIndex">
            <summary>
            Sub Index number (addressing scheme of <see cref="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.CANOPEN_OD"/>).
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.BlockCount">
            <summary>
            Number of parameters for block access (addressing scheme of <see cref="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.PARAMETER_BLOCK"/>).
            </summary>
            <remarks>
            eCMP Specification: V1.0.
            </remarks>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.NullDataCount">
            <summary>
            Amount of null data for the <see cref="F:ControlTechniques.CommsServer.T_PARAMETER_ADDRESSING_SCHEME.NULL"/> scheme.
            Typically this will be specified in multiples of 4.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterID.NumberOfTxBytes">
            <summary>
            Gets the number of bytes required in transmission of the parameter ID.
            The number of bytes vary depending upon the addressing scheme.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs">
            <summary>
            Represents a parameter identifier and its value and number of decimal places.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs.#ctor(ControlTechniques.CommsServer.ParameterID,ControlTechniques.CommsServer.ParameterValue,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="parameterId">Parameter identifier.</param>
            <param name="value">Value.</param>
            <param name="decimalPlaces">Number of decimal places for value.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor for use with simple menu.parameter=int-value scenarios.
            </summary>
            <summary>
            For cases where mode advanced parameter addressing or different value datatypes are required, use the other constructor.
            </summary>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number.</param>
            <param name="value">Integer value.</param>
            <param name="decimalPlaces">Number of decimal places for value.</param>        
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs.Equals(System.Object)">
            <summary>
            Equality check.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs.ParameterID">
            <summary>
            Parameter identifier.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs.Value">
            <summary>
            Parameter value.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs.DecimalPlaces">
            <summary>
            Number of decimal places.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs.DecimalValue">
            <summary>
            Gets the value as a decimal value using the <see cref="P:ControlTechniques.CommsServer.ParameterIDAndValueAndDPs.DecimalPlaces"/> value.
            </summary>
            <returns>Value as a decimal.</returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.ParameterValue">
            <summary>
            A parameter value class.
            
            The parameter data type indicates which property returns the correct
            data.
            
            All integer data up to 32 bits in size is returned via the INTData (signed)
            or UINTData (unsigned) properties.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValue.CreateINT32Value(System.Int32)">
            <summary>
            Create a signed 32-bit integer value.
            </summary>
            <param name="value">Value.</param>
            <returns>Value object.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValue.CreateUINT32Value(System.UInt32)">
            <summary>
            Create a unsigned 32-bit integer value.
            </summary>
            <param name="value">Value.</param>
            <returns>Value object.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValue.CreateINT64Value(System.Int64)">
            <summary>
            Create a signed 64-bit integer value.
            </summary>
            <param name="value">Value.</param>
            <returns>Value object.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValue.CreateUINT64Value(System.UInt64)">
            <summary>
            Create a unsigned 64-bit integer value.
            </summary>
            <param name="value">Value.</param>
            <returns>Value object.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValue.Equals(System.Object)">
            <summary>
            Determines if this value is the same as another.
            </summary>
            <param name="obj">Value to compare against.</param>
            <returns>True if equal, false if not.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValue.CreateValue(System.Byte[],System.Int32@)">
            <summary>
            Reads a value from an array of bytes. The first byte in the frame (at index From) must indicate
            the data type.
            </summary>
            <param name="Frame"></param>
            <param name="From"></param>
            <param name="TheDataType"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValue.CreateValue(System.Byte[],System.Int32@,ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA)">
            <summary>
            Reads a value from an array of bytes. The data type must be indicated by the caller.
            </summary>
            <param name="Frame"></param>
            <param name="From"></param>
            <param name="TheDataType"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValue.ToDecimal(System.Int32)">
            <summary>
            Gets the value as a decimal value with the given precision.
            </summary>
            <param name="precision">The precision, so 0 means whole number, 1 means one decimal place, etc.</param>
            <returns>Value as a decimal.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.DataType">
            <summary>
            The data type of the value. The actual value property you use is dependent upon which this is set to.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.BOOLEANData">
            <summary>
            Boolean value. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one <see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.BOOLEAN_TYPE"/>.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.INTData">
            <summary>
            Integer data. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one of:
            <ul>
             <li><see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.INT8_TYPE"/></li>
             <li><see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.INT16_TYPE"/></li>
             <li><see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.INT32_TYPE"/></li>
            </ul>
            <see cref="T:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA"/>
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.UINTData">
            <summary>
            Unsigned integer data. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one of:
            <ul>
             <li><see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.UINT8_TYPE"/></li>
             <li><see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.UINT16_TYPE"/></li>
             <li><see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.UINT32_TYPE"/></li>
            </ul>
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.INT64Data">
            <summary>
            Integer data. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one <see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.INT64_TYPE"/>.
            Not all target devices will support 64-bit values.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.UINT64Data">
            <summary>
            Integer data. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one <see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.UINT64_TYPE"/>.
            Not all target devices will support 64-bit values.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.SINGLEData">
            <summary>
            Single floating point value. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one <see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.SINGLE_TYPE"/>.
            Not all target devices will support this data type.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.DOUBLEData">
            <summary>
            Double floating point value. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one <see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.DOUBLE_TYPE"/>.
            Not all target devices will support this data type.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.STRINGData">
            <summary>
            String data. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one <see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.STRING_TYPE"/>.
            Not all target devices will support this data type.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValue.STRING_IDData">
            <summary>
            String ID value. Use this when <see cref="P:ControlTechniques.CommsServer.ParameterValue.DataType"/> is one <see cref="F:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA.STRING_ID_TYPE"/>.
            Not all target devices will support this data type.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ParameterValue.T_PARAMETER_ACCESS_DATA">
            <summary>
            The supported parameter data types.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ParameterValueAndStatus">
            <summary>
            Class representing a parameter value and its status.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValueAndStatus.#ctor(ControlTechniques.CommsServer.T_PARAMETER_ACCESS_STATUS,ControlTechniques.CommsServer.ParameterValue)">
            <summary>
            Constructor.
            </summary>
            <param name="TheStatus"></param>
            <param name="TheValue"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterValueAndStatus.CreateValueAndStatus(System.Byte[],System.Int32@)">
            <summary>
            Create a value and status object.
            </summary>
            <param name="Frame"></param>
            <param name="From"></param>
            <returns></returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValueAndStatus.Status">
            <summary>
            Access status.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValueAndStatus.Value">
            <summary>
            Value.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterValueAndStatus.OK">
            <summary>
            Indicates if the access was OK (set true also for clamped and converted status codes).
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.ParameterWithType">
            <summary>
            Represents a parameter with type information such as the number of decimal places.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.ParameterWithType.#ctor(ControlTechniques.CommsServer.ParameterValueAndStatus,System.Int32,System.Int32,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="TheValueAndStatus">Value.</param>
            <param name="TheDecimalPlaces">Number of decimal places.</param>
            <param name="TheUnitsNumber">Units number.</param>
            <param name="TheCustomUnits">Custom units string.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterWithType.ValueAndStatus">
            <summary>
            Value and value status.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterWithType.DecimalPlaces">
            <summary>
            Number of decimal places. -1 indicates either no decimal places or DPs unknown.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterWithType.DecimalValue">
            <summary>
            Gets the value as a decimal value using the <see cref="P:ControlTechniques.CommsServer.ParameterWithType.DecimalPlaces"/> value.
            Same as calling ValueAndStatus.Value.ToDecimal(DecimalPlaces).
            </summary>
            <returns>Value as a decimal.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterWithType.UnitsNumber">
            <summary>
            The units number. 255 = custom units with the string specified in the CustomUnits property.
            </summary>
            <remarks>
            Common units are defined in the <see cref="T:ControlTechniques.CommsServer.T_PARAMETER_UNITS"/> enumeration (though that list may not be exhaustive). 
            </remarks>
            <seealso cref="T:ControlTechniques.CommsServer.T_PARAMETER_UNITS"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.ParameterWithType.CustomUnits">
            <summary>
            This will be an empty string unless the UnitsNumber property has the value 255.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.Protocol">
            <summary>
            Defines protocols that support eCMP.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.Protocol.Equals(System.Object)">
            <summary>
            The equality operator.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Protocol.EthernetProtocol">
            <summary>
            Create an Ethernet protocol.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Protocol.RTUProtocol(System.Int32,ControlTechniques.CommsServer.BaudRate.T_BAUD_RATE)">
            <summary>
            Create an RTU protocol.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Protocol.DefaultRTUProtocol">
            <summary>
            Returns the default RTU protocol on the lowest available COM port.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.Protocol.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ControlTechniques.CommsServer.Protocol"/> class from the provided serialization object.
            </summary>
            <param name="info">The serialization information object containing the object data.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.Protocol.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with the data needed to serialize the target object.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"/>) for this serialization.</param>
            <exception cref="T:System.Security.SecurityException">
            The caller does not have the required permission.
            </exception>
        </member>
        <member name="M:ControlTechniques.CommsServer.Protocol.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ControlTechniques.CommsServer.Protocol.ToString">
            <summary>Returns the protocol as a string for debugging purposes.</summary>
            <returns>String.</returns>
        </member>
        <member name="P:ControlTechniques.CommsServer.Protocol.Value">
            <summary>
            The protocol.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Protocol.BaudRate">
            <summary>
            Baud rate - only applicable for RTU.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.Protocol.ComPort">
            <summary>
            ComPort - only applicable for RTU.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.Protocol.T_PROTOCOL">
            <summary>
            The allowed communications protocols.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.PollingCommsUser">
            <summary>
            Provides a "comms user" that requires you "poll" for responses.
            </summary>
            <remarks>
            It is recommended to use <see cref="T:ControlTechniques.CommsServer.ASynchronousCommsUser"/> which provides an event based system.
            
            If you insist on using this class then remember to sleep / do events in your polling loop otherwise you risk your
            program becoming unresponsive and may even prevent comms response from being handled. Avoid using this class in a UI thread.
            The <see cref="T:ControlTechniques.CommsServer.BlockingCommsUser"/> may be used as an alternative - that does the polling loop part but waits on a semaphore 
            so releasing the thread.
            </remarks>
            <seealso cref="T:ControlTechniques.CommsServer.ASynchronousCommsUser"/>
            <seealso cref="T:ControlTechniques.CommsServer.BlockingCommsUser"/>
        </member>
        <member name="F:ControlTechniques.CommsServer.PollingCommsUser.mPort">
            <summary>
            The current Comms Port.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PollingCommsUser.mResponse">
            <summary>
            The received message response.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PollingCommsUser._maxTransmitBufferSize">
            <summary>
            Maximum transmit buffer size for this user.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.#ctor">
            <summary>
            Construct the user.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.ReleasePort">
            <summary>
            Releases the port used by the user.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.SetTimeouts(ControlTechniques.CommsServer.CommunicationsTimeouts)">
            <summary>
            Set the timeouts for the process.
            </summary>
            <param name="timeouts"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Timeouts">
            <summary>
            Returns the communications timeout.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Go(ControlTechniques.CommsServer.Protocol)">
            <summary>
            Switches the user on to the specified protocol. If a protocol has been previously set the
            user object will relinquish its use of the port.
            </summary>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Stop">
            <summary>
            Turn the user off and release the port.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.CancelTransfer">
            <summary>
            Requests any current file transfer to be cancelled.
            </summary>
            <remarks>
            If there is no active file transfer then calling this will do nothing.
            If the a transfer is successfully cancelled then the response status for the active request will be <see cref="F:ControlTechniques.CommsServer.T_RESPONSE_STATUS.FAILED_CANCELLED"/> with a
            file status of <see cref="F:ControlTechniques.CommsServer.T_FILE_STATUS.FAIL_CANCELLED"/>.
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Transmit(ControlTechniques.CommsServer.MessageQueueRequest)">
            <summary>
            Transmits a message.
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Compound(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCompoundRequest)">
            <summary>
            Send a compound request to a device.
            
            The Response event will return an object of type ECMPCompoundResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Identify(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPIdentifyRequest)">
            <summary>
            Get Identify data from the target.
            
            The Response event will return an object of type ECMPIdentifyResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Info(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest)">
            <summary>
            Get Info data from the target.
            
            The Response event will return an object of type ECMPInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Interrogate(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInterrogateRequest)">
            <summary>
            Interrogate the target to determine if commands are supported or not.
            </summary>
            <param name="address">Address of target</param>
            <param name="request">The request</param>
            <returns>A status.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Reset(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPResetRequest)">
            <summary>
            Reset the target.
            
            The Response event will return an object of type ECMPResetResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.TunnelFrame(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.TunnelFrameRequest)">
            <summary>
            Send a TunnelFrame message to the target.
            
            Note: The commsserver will automatically break the data into chunks
            for transmission, e.g. you can send 10K bytes and the comms layer
            will send a series of messages to get the data into the target.
            
            The Response event will return an object of type TunnelFrameResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest)">
            <summary>
            Read parameter values from the target.
            
            The response will be an object of type ECMPReadResponse. 
            </summary>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)">
            <summary>
            Read a parameter from the target.
            </summary>
            <remarks>
            The response will be an object of type <see cref="T:ControlTechniques.CommsServer.ECMPReadResponse"/>. 
            The values returned won't indicate things like number of decimal places. If you wish to get more information use <see cref="M:ControlTechniques.CommsServer.PollingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>.
            </remarks>
            <param name="address">Device address.</param>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number</param>
            <returns>Status of read request.</returns>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadRequest)"/>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest)">
            <summary>
            Read parameter values with type information from the target.
            
            The Response will be an object of type ECMPReadWithTypeResponse. 
            </summary>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)">
            <summary>
            Read a parameter from the target with full type information.
            </summary>
            <remarks>
            The response will be an object of type <see cref="T:ControlTechniques.CommsServer.ECMPReadWithTypeResponse"/>. 
            </remarks>
            <param name="address">Device address.</param>
            <param name="menu">Menu number.</param>
            <param name="parameter">Parameter number</param>
            <returns>Status of read request.</returns>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.ReadWithType(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPReadWithTypeRequest)"/>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.Read(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest)">
            <summary>
            Write parameter values to the target.
            
            The response will be an object of type ECMPWriteResponse. 
            </summary>
            <param name="address">Target address</param>
            <param name="request">The request</param>
            <returns>Status.</returns>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write a parameter value to the target.
            </summary>
            <remarks>
            This function provides a simple fixed-point integer value write. For other parameter types, data types or multiple
            parameter writes, use <see cref="M:ControlTechniques.CommsServer.PollingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest)"/>/
            
            The response will be an object of type <see cref="T:ControlTechniques.CommsServer.ECMPWriteResponse"/>. 
            </remarks>
            <param name="address">Target address</param>
            <param name="menu">The menu number</param>
            <param name="parameter">Parameter number</param>
            <param name="value"></param>
            <param name="dpos">Decimal places (precision) of the value.</param>
            <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.Write(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPWriteRequest)"/>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.ObjectInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPObjectInfoRequest)">
            <summary>
            Get Object Info from the target.
            
            The Response event will return an object of type ECMPObjectInfoResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.GetNextObjects(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPGetNextObjectsRequest)">
            <summary>
            Get Next Objects from the target.
            
            The Response event will return an object of type ECMPGetNextObjectsResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileDelete(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileDeleteMessageRequest)">
            <summary>
            Delete a file on the target.
            
            The Response event will return an object of type FileDeleteMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FolderCreate(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FolderCreateMessageRequest)">
            <summary>
            Create a folder on the target.
            
            The Response event will return an object of type FolderCreateMessageResponse. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileReadBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadBytesMessageRequest)">
            <summary>
            Read the contents of a target file into an array of bytes.
            
            The Response event will return an object of type FileReadBytesMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileReadDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileReadDiskMessageRequest)">
            <summary>
            Read the contents of a target file into a file on disk.
            
            The Response event will return an object of type FileReadDiskMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileWriteBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest)">
            <summary>
            Write the contents of a target file from an array of bytes.
            
            The Response event will return an object of type FileWriteBytesMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileWriteDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest)">
            <summary>
            Write the contents of a target file from a file on disk.
            
            The Response event will return an object of type FileWriteDiskMessageResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileIsWriteOnly(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileIsWriteOnlyCheckMessageRequest)">
            <summary>
            Check if the specified target file is write-only
            </summary>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name to check</param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileList(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileListRequest)">
            <summary>
            Obtain a list of files in a given directory.
            
            The Response event will return an object of type FileListResponse. 
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileExists(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileExistsRequest)">
            <summary>
            Check if the specified target file exists.
            </summary>
            <remarks>
            The existence check can be done two ways: (1) By attempting to open the file, or (2) issuing a ECMP FileExists
            command. By default method 1 is used since many devices do not support FileExists command and so this method is more
            compatbile. However you can force method 2 to be used instead by specifying <see cref="P:ControlTechniques.CommsServer.FileExistsRequest.UseFileExistsCommand"/>=true.
            </remarks>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name to check</param>
            <returns>Status of the request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.FileInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileInfoRequest)">
            <summary>
            Request information about a file such as its file length.
            </summary>
            <remarks>
            Not all tagets will support this command, and the which attributes are supported is also target and file location dependant.
            Certain targets may also impose a limit on how many attributes may be requested in one request. 
            </remarks>
            <param name="address">The address of the target device holding the file</param>
            <param name="request">The request containing the target file name and the attributes to get.</param>
            <returns>Status of the request.</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.GetSyncInfo(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPSyncInfoRequest)">
            <summary>
            Get Sync Info
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.CyclicLink(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)">
            <summary>
            Get Cyclic Link Information
            </summary>
            <remarks>The new <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)"/> method should be used for newer targets adhearing to the V1.0 ECMP specification.</remarks>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.CyclicLink2(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPCyclicLinkRequestBase)">
            <summary>
            Get Cyclic Link Information
            </summary>
            <param name="address">address of target</param>
            <param name="request">request to send</param>
            <returns>status of operation</returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.GetDiagnostics(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPDiagnosticRequest)">
            <summary>
            Get Diagnostics information
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.GetProgramStatus(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPProgramStatusRequest)">
            <summary>
            Get the status of the program running
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.SetProgramControl(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPProgramControlRequest)">
            <summary>
            Get the status of the program running
            </summary>
            <param name="address"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.ResponseWaiting(System.Object@,ControlTechniques.CommsServer.T_RESPONSE_STATUS@)">
            <summary>
            After a transmission, this method should be polled until it returns true, at which time the
            Response and Status fields will have meaningful values. Note that the Response argument should
            only be used when a Status of OK is returned - for other statuses Response may be null.
            </summary>
            <param name="Response"></param>
            <param name="Status"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PollingCommsUser.HandleMessageQueueResponse(ControlTechniques.CommsServer.MessageQueueRequest,ControlTechniques.CommsServer.MessageQueueResponse)">
            <summary>
            Invoke the subscribed events on their original threads.
            </summary>
            <param name="TheRequest"></param>
            <param name="TheResponse"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.PollingCommsUser.FileTransferProgress">
            <summary>
            The progress of the current file transfer action
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.PollingCommsUser.MaxTransmitBufferSizeBytes">
             <summary>
             Sets/gets the maximum number of bytes sent in a file transfer or tunneled frame.
             </summary>
             <remarks>
             An out-of-range value will be ignored (range 16-1000).
             
             The default value should be suitable in most cases. The value can be set to the <see cref="P:ControlTechniques.CommsServer.ECMPInfoResponse.BufferSizeBytes"/> obtained from the target.
            
             Note that file transfer (using <see cref="M:ControlTechniques.CommsServer.PollingCommsUser.FileWriteDisk(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteDiskMessageRequest)"/> and <see cref="M:ControlTechniques.CommsServer.PollingCommsUser.FileWriteBytes(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.FileWriteBytesMessageRequest)"/>) automatically query the target device for its buffer size 
             and will use that value for the file transfer. To force the value of this property to be used instead specify the <see cref="F:ControlTechniques.CommsServer.FileWriteOptions.DisableAutoBufferSize"/> flag
             in the request.
             </remarks>
             <seealso cref="M:ControlTechniques.CommsServer.PollingCommsUser.Info(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPInfoRequest)"/>
        </member>
        <member name="P:ControlTechniques.CommsServer.PollingCommsUser.IsActive">
            <summary>
            Returns whether the user is active, i.e. <see cref="M:ControlTechniques.CommsServer.PollingCommsUser.Go(ControlTechniques.CommsServer.Protocol)"/> has been called.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.PollingCommsUser.TheProtocol">
            <summary>
            Returns the protocol currently in use by the user. null may be
            returned if the user has not called Go (or has since called Stop).
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.PollingCommsUser.T_USER_STATUS">
            <summary>
            Operation statuses.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileWriteBytesMessageRequest">
            <summary>
            A request to write data to a device.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileWriteBytesMessageRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileWriteBytesMessageRequest.#ctor(System.Byte[],System.String,ControlTechniques.CommsServer.FileWriteOptions)">
            <summary>
            Constructor.
            </summary>
            <param name="data">The data to write.</param>
            <param name="targetFileName">Filename to write to on target device.</param>
            <param name="options">Options. Default is none.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileWriteBytesMessageRequest.Bytes">
            <summary>
            The bytes to be written.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileWriteBytesMessageResponse">
            <summary>
            Response to a <see cref="T:ControlTechniques.CommsServer.FileWriteBytesMessageRequest"/>.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileWriteBytesMessageResponse.#ctor(ControlTechniques.CommsServer.FileWriteBytesMessageRequest)">
            <summary>
            Constructor.
            </summary>
            <param name="request">The original request</param>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileWriteDiskMessageRequest">
            <summary>
            A request to write a file from disk to a device.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileWriteDiskMessageRequest.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileWriteDiskMessageRequest.#ctor(System.String,System.String,ControlTechniques.CommsServer.FileWriteOptions)">
            <summary>
            Constructor.
            </summary>
            <param name="diskFileName">File name for the file to write.</param>
            <param name="targetFileName">Filename to write to on target device.</param>
            <param name="options">Options. Default is none.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileWriteDiskMessageRequest.DiskFileName">
            <summary>
            Name of file on PC that will be written to the device.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileWriteDiskMessageResponse">
            <summary>
            Response to a file write request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileWriteDiskMessageResponse.#ctor(ControlTechniques.CommsServer.FileWriteDiskMessageRequest)">
            <summary>
            Constructor.
            </summary>
            <param name="request">The original request.</param>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileReadBytesMessageRequest">
            <summary>
            Request to read a target file into a byte array. The response will be a <see cref="T:ControlTechniques.CommsServer.FileReadBytesMessageResponse"/>.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileReadBytesMessageRequest.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileReadBytesMessageRequest.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="targetFileName">File to read from device.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadBytesMessageRequest.TargetFileName">
            <summary>
            Filename on the device.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileReadBytesMessageResponse">
            <summary>
            Response to a <see cref="T:ControlTechniques.CommsServer.FileReadBytesMessageRequest"/>.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileReadBytesMessageResponse.#ctor(ControlTechniques.CommsServer.FileReadBytesMessageRequest)">
            <summary>
            Constructor.
            </summary>
            <param name="TheRequest"></param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadBytesMessageResponse.Request">
            <summary>
            The original request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadBytesMessageResponse.TargetFileName">
            <summary>
            The name of the file on the device.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadBytesMessageResponse.Bytes">
            <summary>
            The data read.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadBytesMessageResponse.Status">
            <summary>
            The status.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadBytesMessageResponse.TimeTaken">
            <summary>
            Overall time the file write took.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.FileReadDiskMessageRequest">
            <summary>
            A request to read a file from a device to a file.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileReadDiskMessageRequest.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FileReadDiskMessageRequest.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>        
            <param name="targetFileName">Filename to read to on target device.</param>
            /// <param name="diskFileName">File name on PC to write to.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadDiskMessageRequest.TargetFileName">
            <summary>
            File on the target (remote) device.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadDiskMessageRequest.DiskFileName">
            <summary>
            File on the PC to write to.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.FileReadDiskMessageResponse.TimeTaken">
            <summary>
            Overall time the file write took.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.FormCommsHandler.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.FormCommsHandler.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ControlTechniques.CommsServer.FormCommsHandler.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.MessageQueueRequest">
            <summary>
            This class defines a comms message queue request.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.MessageQueueRequest.#ctor(ControlTechniques.CommsServer.CommsAddress,ControlTechniques.CommsServer.ECMPUserRequest,ControlTechniques.CommsServer.InterfaceMessageQueueResponseNotification,ControlTechniques.CommsServer.ICommsUser)">
            <summary>
            Construct the request.
            </summary>
            <param name="address">Comms address of device to send message to.</param>
            <param name="request">The request</param>
            <param name="notificationInterface">Interface on which to pass the response to.</param>
            <param name="user">The comms user that initiated this request. If this is not passed in (or null is passed in) then a check is made to see if the
            <paramref name="notificationInterface"/> is actually also a ICommsUser and if so, that will be used.</param>
        </member>
        <member name="P:ControlTechniques.CommsServer.MessageQueueRequest.Address">
            <summary>
            The address to send the request to.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.MessageQueueRequest.Request">
            <summary>
            The actual request.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.MessageQueueRequest.NotificationInterface">
            <summary>
            An interface on which the client is to be notified of success/ fail.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.MessageQueueRequest.CommsUser">
            <summary>
            The comms user which this request relates to.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.PortManager">
            <summary>
            Manages the communications for a single port.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PortManager.mPorts">
            <summary>
            The ports - indexed by protocol.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PortManager._uiThread">
            <summary>
            Window UI thread.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PortManager._commsForm">
            <summary>
            Form used for message pumping.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortManager.Initialise">
            <summary>
            Initialise the comms.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortManager.ForProtocol(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.T_STATUS@)">
            <summary>
            Get the port for a specific protocol. null is returned if no such port is defined.
            </summary>
            <param name="TheProtocol"></param>
            <returns></returns>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortManager.ReleasePort(ControlTechniques.CommsServer.PortManager.Port,System.Boolean)">
            <summary>
            Releases the port for a specific protocol, i.e. decrements its reference count. If the count is 0, the port
            is stopped and discarded.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortManager.ReleaseLoop(ControlTechniques.CommsServer.DataLoop)">
            <summary>
            Releases the loop for a specific protocol, i.e. decrements its reference count. If the count is 0, the loop
            is stopped and discarded.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortManager.LoopForProtocol(ControlTechniques.CommsServer.Protocol,ControlTechniques.CommsServer.T_STATUS@)">
            <summary>
            Get the data loop for a specific protocol. null is returned if loop creation fails.
            </summary>
            <param name="TheProtocol"></param>
            <returns></returns>
        </member>
        <member name="T:ControlTechniques.CommsServer.PortManager.Port">
            <summary>
            The comms components for a single port, e.g. a single COM port or for Ethernet.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PortManager.Port.mLoop">
            <summary>
            The data loop for the port.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortManager.Port.#ctor">
            <summary>
            Construct the port.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortManager.Port.InvalidateLoopParameters(ControlTechniques.CommsServer.CommsAddress,System.Collections.Generic.List{ControlTechniques.CommsServer.ParameterIDAndValueAndDPs})">
            <summary>
            Mark the specified parameters as unread so that they are refreshed via the loop.
            </summary>
            <param name="Parameters"></param>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortManager.Port.Stop">
            <summary>
            Stops the port and its loop.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.PortManager.Port.ReferenceCount">
            <summary>
            The number of users of the port.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.PortManager.Port.Queue">
            <summary>
            The message queue for the port.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.PortManager.Port.PortProtocol">
            <summary>
            The Port protocol.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.PortManager.Port.LoopReferenceCount">
            <summary>
            The number of users of the port.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.PortManager.Port.TheLoop">
            <summary>
            The data loop for the port.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.PortServerCommand">
            <summary>
            Thread-safe commanding for the Server Thread.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PortServerCommand.mSemaphore">
            <summary>
            Create a thread-safe semaphore.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PortServerCommand.mMessage">
            <summary>
            The message (which may be null) accompanying the command.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PortServerCommand.mCommand">
            <summary>
            The command.
            </summary>
        </member>
        <member name="F:ControlTechniques.CommsServer.PortServerCommand._syncObject">
            <summary>
            This object is used to synchronise access across threads
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortServerCommand.Release">
            <summary>
            Release the command.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortServerCommand.SetCommand(ControlTechniques.CommsServer.PortServerCommand.T_COMMAND,ControlTechniques.CommsServer.ECMPMessageResponseBase)">
            <summary>
            Set a command.
            </summary>
        </member>
        <member name="M:ControlTechniques.CommsServer.PortServerCommand.GetCommand(ControlTechniques.CommsServer.PortServerCommand.T_COMMAND@,ControlTechniques.CommsServer.ECMPMessageResponseBase@,ControlTechniques.CommsServer.T_RESPONSE_STATUS@)">
            <summary>
            Wait until a command is available.
            </summary>
            <param name="Command"></param>
            <param name="Response"></param>
        </member>
        <member name="T:ControlTechniques.CommsServer.PortServerCommand.T_COMMAND">
            <summary>
            The command type.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.TunnelFrameRequest">
            <summary>
            A block of bytes to be transmitted to a device. The byte array can be of any size, the server will
            chunk it appropriately to get the entire block of data into the device.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.TunnelFrameRequest.Bytes">
            <summary>
            The bytes of data to tunnel to the target
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.TunnelFrameRequest.CheckOutput">
            <summary>
            Set to true if the response generated by the tunnel target should be sent back to the request instigator
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.TunnelFrameRequest.IgnoreControlFlags">
            <summary>
            If set to true the control flags for the request will be set to zero, this is to get around an issue with the drive firmware that will
            later be corrected
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.TunnelFrameRequest.OverridingTimeout">
            <summary>
            An overriding timeout to use for this specific tunnel frame request. This should only be set for special transient situations where it is known 
            a device may take longer to respond than normal.
            By default the <see cref="P:ControlTechniques.CommsServer.CommunicationsTimeouts.TunnelMessageTimeout"/> is used.         
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.TunnelFrameResponse">
            <summary>
            A block of bytes received from a device. The byte array can be of any size, the server will
            chunk it appropriately to get the entire block of data out of the device.
            </summary>
        </member>
        <member name="T:ControlTechniques.CommsServer.VersionInfo">
            <summary>
            Provides comms layer version numbers.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.VersionInfo.ECMPLayerVerison">
            <summary>
            This DLL's version number.
            </summary>
        </member>
        <member name="P:ControlTechniques.CommsServer.VersionInfo.CommsServerVersion">
            <summary>
            The CTCommsServer version number.
            </summary>
        </member>
    </members>
</doc>
